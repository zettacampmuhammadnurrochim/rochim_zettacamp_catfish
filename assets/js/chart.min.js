/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
! function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e()
}(this, (function () {
            "use strict";

            function t() {}
            const e = function () {
                let t = 0;
                return function () {
                    return t++
                }
            }();

            function i(t) {
                return null == t
            }

            function s(t) {
                if (Array.isArray && Array.isArray(t)) return !0;
                const e = Object.prototype.toString.call(t);
                return "[object" === e.slice(0, 7) && "Array]" === e.slice(-6)
            }

            function n(t) {
                return null !== t && "[object Object]" === Object.prototype.toString.call(t)
            }
            const o = t => ("number" == typeof t || t instanceof Number) && isFinite(+t);

            function a(t, e) {
                return o(t) ? t : e
            }

            function r(t, e) {
                return void 0 === t ? e : t
            }
            const l = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : t / e,
                h = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

            function c(t, e, i) {
                if (t && "function" == typeof t.call) return t.apply(i, e)
            }

            function d(t, e, i, o) {
                let a, r, l;
                if (s(t))
                    if (r = t.length, o)
                        for (a = r - 1; a >= 0; a--) e.call(i, t[a], a);
                    else
                        for (a = 0; a < r; a++) e.call(i, t[a], a);
                else if (n(t))
                    for (l = Object.keys(t), r = l.length, a = 0; a < r; a++) e.call(i, t[l[a]], l[a])
            }

            function u(t, e) {
                let i, s, n, o;
                if (!t || !e || t.length !== e.length) return !1;
                for (i = 0, s = t.length; i < s; ++i)
                    if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;
                return !0
            }

            function f(t) {
                if (s(t)) return t.map(f);
                if (n(t)) {
                    const e = Object.create(null),
                        i = Object.keys(t),
                        s = i.length;
                    let n = 0;
                    for (; n < s; ++n) e[i[n]] = f(t[i[n]]);
                    return e
                }
                return t
            }

            function g(t) {
                return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
            }

            function p(t, e, i, s) {
                if (!g(t)) return;
                const o = e[t],
                    a = i[t];
                n(o) && n(a) ? m(o, a, s) : e[t] = f(a)
            }

            function m(t, e, i) {
                const o = s(e) ? e : [e],
                    a = o.length;
                if (!n(t)) return t;
                const r = (i = i || {}).merger || p;
                for (let s = 0; s < a; ++s) {
                    if (!n(e = o[s])) continue;
                    const a = Object.keys(e);
                    for (let s = 0, n = a.length; s < n; ++s) r(a[s], t, e, i)
                }
                return t
            }

            function b(t, e) {
                return m(t, e, {
                    merger: x
                })
            }

            function x(t, e, i) {
                if (!g(t)) return;
                const s = e[t],
                    o = i[t];
                n(s) && n(o) ? b(s, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = f(o))
            }
            const _ = {
                "": t => t,
                x: t => t.x,
                y: t => t.y
            };

            function y(t, e) {
                const i = _[e] || (_[e] = function (t) {
                    const e = v(t);
                    return t => {
                        for (const i of e) {
                            if ("" === i) break;
                            t = t && t[i]
                        }
                        return t
                    }
                }(e));
                return i(t)
            }

            function v(t) {
                const e = t.split("."),
                    i = [];
                let s = "";
                for (const t of e) s += t, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (i.push(s), s = "");
                return i
            }

            function w(t) {
                return t.charAt(0).toUpperCase() + t.slice(1)
            }
            const M = t => void 0 !== t,
                k = t => "function" == typeof t,
                S = (t, e) => {
                    if (t.size !== e.size) return !1;
                    for (const i of t)
                        if (!e.has(i)) return !1;
                    return !0
                };

            function P(t) {
                return "mouseup" === t.type || "click" === t.type || "contextmenu" === t.type
            }
            const D = Math.PI,
                O = 2 * D,
                C = O + D,
                A = Number.POSITIVE_INFINITY,
                T = D / 180,
                L = D / 2,
                E = D / 4,
                R = 2 * D / 3,
                I = Math.log10,
                z = Math.sign;

            function F(t) {
                const e = Math.round(t);
                t = N(t, e, t / 1e3) ? e : t;
                const i = Math.pow(10, Math.floor(I(t))),
                    s = t / i;
                return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i
            }

            function V(t) {
                const e = [],
                    i = Math.sqrt(t);
                let s;
                for (s = 1; s < i; s++) t % s == 0 && (e.push(s), e.push(t / s));
                return i === (0 | i) && e.push(i), e.sort(((t, e) => t - e)).pop(), e
            }

            function B(t) {
                return !isNaN(parseFloat(t)) && isFinite(t)
            }

            function N(t, e, i) {
                return Math.abs(t - e) < i
            }

            function W(t, e) {
                const i = Math.round(t);
                return i - e <= t && i + e >= t
            }

            function j(t, e, i) {
                let s, n, o;
                for (s = 0, n = t.length; s < n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o))
            }

            function H(t) {
                return t * (D / 180)
            }

            function $(t) {
                return t * (180 / D)
            }

            function Y(t) {
                if (!o(t)) return;
                let e = 1,
                    i = 0;
                for (; Math.round(t * e) / e !== t;) e *= 10, i++;
                return i
            }

            function U(t, e) {
                const i = e.x - t.x,
                    s = e.y - t.y,
                    n = Math.sqrt(i * i + s * s);
                let o = Math.atan2(s, i);
                return o < -.5 * D && (o += O), {
                    angle: o,
                    distance: n
                }
            }

            function X(t, e) {
                return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
            }

            function q(t, e) {
                return (t - e + C) % O - D
            }

            function K(t) {
                return (t % O + O) % O
            }

            function G(t, e, i, s) {
                const n = K(t),
                    o = K(e),
                    a = K(i),
                    r = K(o - n),
                    l = K(a - n),
                    h = K(n - o),
                    c = K(n - a);
                return n === o || n === a || s && o === a || r > l && h < c
            }

            function Z(t, e, i) {
                return Math.max(e, Math.min(i, t))
            }

            function J(t) {
                return Z(t, -32768, 32767)
            }

            function Q(t, e, i, s = 1e-6) {
                return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s
            }

            function tt(t, e, i) {
                i = i || (i => t[i] < e);
                let s, n = t.length - 1,
                    o = 0;
                for (; n - o > 1;) s = o + n >> 1, i(s) ? o = s : n = s;
                return {
                    lo: o,
                    hi: n
                }
            }
            const et = (t, e, i, s) => tt(t, i, s ? s => t[s][e] <= i : s => t[s][e] < i),
                it = (t, e, i) => tt(t, i, (s => t[s][e] >= i));

            function st(t, e, i) {
                let s = 0,
                    n = t.length;
                for (; s < n && t[s] < e;) s++;
                for (; n > s && t[n - 1] > i;) n--;
                return s > 0 || n < t.length ? t.slice(s, n) : t
            }
            const nt = ["push", "pop", "shift", "splice", "unshift"];

            function ot(t, e) {
                t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
                    configurable: !0,
                    enumerable: !1,
                    value: {
                        listeners: [e]
                    }
                }), nt.forEach((e => {
                    const i = "_onData" + w(e),
                        s = t[e];
                    Object.defineProperty(t, e, {
                        configurable: !0,
                        enumerable: !1,
                        value(...e) {
                            const n = s.apply(this, e);
                            return t._chartjs.listeners.forEach((t => {
                                "function" == typeof t[i] && t[i](...e)
                            })), n
                        }
                    })
                })))
            }

            function at(t, e) {
                const i = t._chartjs;
                if (!i) return;
                const s = i.listeners,
                    n = s.indexOf(e); - 1 !== n && s.splice(n, 1), s.length > 0 || (nt.forEach((e => {
                    delete t[e]
                })), delete t._chartjs)
            }

            function rt(t) {
                const e = new Set;
                let i, s;
                for (i = 0, s = t.length; i < s; ++i) e.add(t[i]);
                return e.size === s ? t : Array.from(e)
            }
            const lt = "undefined" == typeof window ? function (t) {
                return t()
            } : window.requestAnimationFrame;

            function ht(t, e, i) {
                const s = i || (t => Array.prototype.slice.call(t));
                let n = !1,
                    o = [];
                return function (...i) {
                    o = s(i), n || (n = !0, lt.call(window, (() => {
                        n = !1, t.apply(e, o)
                    })))
                }
            }

            function ct(t, e) {
                let i;
                return function (...s) {
                    return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e
                }
            }
            const dt = t => "start" === t ? "left" : "end" === t ? "right" : "center",
                ut = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2,
                ft = (t, e, i, s) => t === (s ? "left" : "right") ? i : "center" === t ? (e + i) / 2 : e;

            function gt(t, e, i) {
                const s = e.length;
                let n = 0,
                    o = s;
                if (t._sorted) {
                    const {
                        iScale: a,
                        _parsed: r
                    } = t, l = a.axis, {
                        min: h,
                        max: c,
                        minDefined: d,
                        maxDefined: u
                    } = a.getUserBounds();
                    d && (n = Z(Math.min(et(r, a.axis, h).lo, i ? s : et(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? Z(Math.max(et(r, a.axis, c, !0).hi + 1, i ? 0 : et(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n
                }
                return {
                    start: n,
                    count: o
                }
            }

            function pt(t) {
                const {
                    xScale: e,
                    yScale: i,
                    _scaleRanges: s
                } = t, n = {
                    xmin: e.min,
                    xmax: e.max,
                    ymin: i.min,
                    ymax: i.max
                };
                if (!s) return t._scaleRanges = n, !0;
                const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;
                return Object.assign(s, n), o
            }
            var mt = new class {
                constructor() {
                    this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
                }
                _notify(t, e, i, s) {
                    const n = e.listeners[s],
                        o = e.duration;
                    n.forEach((s => s({
                        chart: t,
                        initial: e.initial,
                        numSteps: o,
                        currentStep: Math.min(i - e.start, o)
                    })))
                }
                _refresh() {
                    this._request || (this._running = !0, this._request = lt.call(window, (() => {
                        this._update(), this._request = null, this._running && this._refresh()
                    })))
                }
                _update(t = Date.now()) {
                    let e = 0;
                    this._charts.forEach(((i, s) => {
                        if (!i.running || !i.items.length) return;
                        const n = i.items;
                        let o, a = n.length - 1,
                            r = !1;
                        for (; a >= 0; --a) o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());
                        r && (s.draw(), this._notify(s, i, t, "progress")), n.length || (i.running = !1, this._notify(s, i, t, "complete"), i.initial = !1), e += n.length
                    })), this._lastDate = t, 0 === e && (this._running = !1)
                }
                _getAnims(t) {
                    const e = this._charts;
                    let i = e.get(t);
                    return i || (i = {
                        running: !1,
                        initial: !0,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    }, e.set(t, i)), i
                }
                listen(t, e, i) {
                    this._getAnims(t).listeners[e].push(i)
                }
                add(t, e) {
                    e && e.length && this._getAnims(t).items.push(...e)
                }
                has(t) {
                    return this._getAnims(t).items.length > 0
                }
                start(t) {
                    const e = this._charts.get(t);
                    e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh())
                }
                running(t) {
                    if (!this._running) return !1;
                    const e = this._charts.get(t);
                    return !!(e && e.running && e.items.length)
                }
                stop(t) {
                    const e = this._charts.get(t);
                    if (!e || !e.items.length) return;
                    const i = e.items;
                    let s = i.length - 1;
                    for (; s >= 0; --s) i[s].cancel();
                    e.items = [], this._notify(t, e, Date.now(), "complete")
                }
                remove(t) {
                    return this._charts.delete(t)
                }
            };
            /*!
             * @kurkle/color v0.2.1
             * https://github.com/kurkle/color#readme
             * (c) 2022 Jukka Kurkela
             * Released under the MIT License
             */
            function bt(t) {
                return t + .5 | 0
            }
            const xt = (t, e, i) => Math.max(Math.min(t, i), e);

            function _t(t) {
                return xt(bt(2.55 * t), 0, 255)
            }

            function yt(t) {
                return xt(bt(255 * t), 0, 255)
            }

            function vt(t) {
                return xt(bt(t / 2.55) / 100, 0, 1)
            }

            function wt(t) {
                return xt(bt(100 * t), 0, 100)
            }
            const Mt = {
                    0: 0,
                    1: 1,
                    2: 2,
                    3: 3,
                    4: 4,
                    5: 5,
                    6: 6,
                    7: 7,
                    8: 8,
                    9: 9,
                    A: 10,
                    B: 11,
                    C: 12,
                    D: 13,
                    E: 14,
                    F: 15,
                    a: 10,
                    b: 11,
                    c: 12,
                    d: 13,
                    e: 14,
                    f: 15
                },
                kt = [..."0123456789ABCDEF"],
                St = t => kt[15 & t],
                Pt = t => kt[(240 & t) >> 4] + kt[15 & t],
                Dt = t => (240 & t) >> 4 == (15 & t);

            function Ot(t) {
                var e = (t => Dt(t.r) && Dt(t.g) && Dt(t.b) && Dt(t.a))(t) ? St : Pt;
                return t ? "#" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : "")(t.a, e) : void 0
            }
            const Ct = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

            function At(t, e, i) {
                const s = e * Math.min(i, 1 - i),
                    n = (e, n = (e + t / 30) % 12) => i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);
                return [n(0), n(8), n(4)]
            }

            function Tt(t, e, i) {
                const s = (s, n = (s + t / 60) % 6) => i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);
                return [s(5), s(3), s(1)]
            }

            function Lt(t, e, i) {
                const s = At(t, 1, .5);
                let n;
                for (e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - e - i, s[n] += e;
                return s
            }

            function Et(t) {
                const e = t.r / 255,
                    i = t.g / 255,
                    s = t.b / 255,
                    n = Math.max(e, i, s),
                    o = Math.min(e, i, s),
                    a = (n + o) / 2;
                let r, l, h;
                return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function (t, e, i, s, n) {
                    return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4
                }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a]
            }

            function Rt(t, e, i, s) {
                return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(yt)
            }

            function It(t, e, i) {
                return Rt(At, t, e, i)
            }

            function zt(t) {
                return (t % 360 + 360) % 360
            }

            function Ft(t) {
                const e = Ct.exec(t);
                let i, s = 255;
                if (!e) return;
                e[5] !== i && (s = e[6] ? _t(+e[5]) : yt(+e[5]));
                const n = zt(+e[2]),
                    o = +e[3] / 100,
                    a = +e[4] / 100;
                return i = "hwb" === e[1] ? function (t, e, i) {
                    return Rt(Lt, t, e, i)
                }(n, o, a) : "hsv" === e[1] ? function (t, e, i) {
                    return Rt(Tt, t, e, i)
                }(n, o, a) : It(n, o, a), {
                    r: i[0],
                    g: i[1],
                    b: i[2],
                    a: s
                }
            }
            const Vt = {
                    x: "dark",
                    Z: "light",
                    Y: "re",
                    X: "blu",
                    W: "gr",
                    V: "medium",
                    U: "slate",
                    A: "ee",
                    T: "ol",
                    S: "or",
                    B: "ra",
                    C: "lateg",
                    D: "ights",
                    R: "in",
                    Q: "turquois",
                    E: "hi",
                    P: "ro",
                    O: "al",
                    N: "le",
                    M: "de",
                    L: "yello",
                    F: "en",
                    K: "ch",
                    G: "arks",
                    H: "ea",
                    I: "ightg",
                    J: "wh"
                },
                Bt = {
                    OiceXe: "f0f8ff",
                    antiquewEte: "faebd7",
                    aqua: "ffff",
                    aquamarRe: "7fffd4",
                    azuY: "f0ffff",
                    beige: "f5f5dc",
                    bisque: "ffe4c4",
                    black: "0",
                    blanKedOmond: "ffebcd",
                    Xe: "ff",
                    XeviTet: "8a2be2",
                    bPwn: "a52a2a",
                    burlywood: "deb887",
                    caMtXe: "5f9ea0",
                    KartYuse: "7fff00",
                    KocTate: "d2691e",
                    cSO: "ff7f50",
                    cSnflowerXe: "6495ed",
                    cSnsilk: "fff8dc",
                    crimson: "dc143c",
                    cyan: "ffff",
                    xXe: "8b",
                    xcyan: "8b8b",
                    xgTMnPd: "b8860b",
                    xWay: "a9a9a9",
                    xgYF: "6400",
                    xgYy: "a9a9a9",
                    xkhaki: "bdb76b",
                    xmagFta: "8b008b",
                    xTivegYF: "556b2f",
                    xSange: "ff8c00",
                    xScEd: "9932cc",
                    xYd: "8b0000",
                    xsOmon: "e9967a",
                    xsHgYF: "8fbc8f",
                    xUXe: "483d8b",
                    xUWay: "2f4f4f",
                    xUgYy: "2f4f4f",
                    xQe: "ced1",
                    xviTet: "9400d3",
                    dAppRk: "ff1493",
                    dApskyXe: "bfff",
                    dimWay: "696969",
                    dimgYy: "696969",
                    dodgerXe: "1e90ff",
                    fiYbrick: "b22222",
                    flSOwEte: "fffaf0",
                    foYstWAn: "228b22",
                    fuKsia: "ff00ff",
                    gaRsbSo: "dcdcdc",
                    ghostwEte: "f8f8ff",
                    gTd: "ffd700",
                    gTMnPd: "daa520",
                    Way: "808080",
                    gYF: "8000",
                    gYFLw: "adff2f",
                    gYy: "808080",
                    honeyMw: "f0fff0",
                    hotpRk: "ff69b4",
                    RdianYd: "cd5c5c",
                    Rdigo: "4b0082",
                    ivSy: "fffff0",
                    khaki: "f0e68c",
                    lavFMr: "e6e6fa",
                    lavFMrXsh: "fff0f5",
                    lawngYF: "7cfc00",
                    NmoncEffon: "fffacd",
                    ZXe: "add8e6",
                    ZcSO: "f08080",
                    Zcyan: "e0ffff",
                    ZgTMnPdLw: "fafad2",
                    ZWay: "d3d3d3",
                    ZgYF: "90ee90",
                    ZgYy: "d3d3d3",
                    ZpRk: "ffb6c1",
                    ZsOmon: "ffa07a",
                    ZsHgYF: "20b2aa",
                    ZskyXe: "87cefa",
                    ZUWay: "778899",
                    ZUgYy: "778899",
                    ZstAlXe: "b0c4de",
                    ZLw: "ffffe0",
                    lime: "ff00",
                    limegYF: "32cd32",
                    lRF: "faf0e6",
                    magFta: "ff00ff",
                    maPon: "800000",
                    VaquamarRe: "66cdaa",
                    VXe: "cd",
                    VScEd: "ba55d3",
                    VpurpN: "9370db",
                    VsHgYF: "3cb371",
                    VUXe: "7b68ee",
                    VsprRggYF: "fa9a",
                    VQe: "48d1cc",
                    VviTetYd: "c71585",
                    midnightXe: "191970",
                    mRtcYam: "f5fffa",
                    mistyPse: "ffe4e1",
                    moccasR: "ffe4b5",
                    navajowEte: "ffdead",
                    navy: "80",
                    Tdlace: "fdf5e6",
                    Tive: "808000",
                    TivedBb: "6b8e23",
                    Sange: "ffa500",
                    SangeYd: "ff4500",
                    ScEd: "da70d6",
                    pOegTMnPd: "eee8aa",
                    pOegYF: "98fb98",
                    pOeQe: "afeeee",
                    pOeviTetYd: "db7093",
                    papayawEp: "ffefd5",
                    pHKpuff: "ffdab9",
                    peru: "cd853f",
                    pRk: "ffc0cb",
                    plum: "dda0dd",
                    powMrXe: "b0e0e6",
                    purpN: "800080",
                    YbeccapurpN: "663399",
                    Yd: "ff0000",
                    Psybrown: "bc8f8f",
                    PyOXe: "4169e1",
                    saddNbPwn: "8b4513",
                    sOmon: "fa8072",
                    sandybPwn: "f4a460",
                    sHgYF: "2e8b57",
                    sHshell: "fff5ee",
                    siFna: "a0522d",
                    silver: "c0c0c0",
                    skyXe: "87ceeb",
                    UXe: "6a5acd",
                    UWay: "708090",
                    UgYy: "708090",
                    snow: "fffafa",
                    sprRggYF: "ff7f",
                    stAlXe: "4682b4",
                    tan: "d2b48c",
                    teO: "8080",
                    tEstN: "d8bfd8",
                    tomato: "ff6347",
                    Qe: "40e0d0",
                    viTet: "ee82ee",
                    JHt: "f5deb3",
                    wEte: "ffffff",
                    wEtesmoke: "f5f5f5",
                    Lw: "ffff00",
                    LwgYF: "9acd32"
                };
            let Nt;

            function Wt(t) {
                Nt || (Nt = function () {
                    const t = {},
                        e = Object.keys(Bt),
                        i = Object.keys(Vt);
                    let s, n, o, a, r;
                    for (s = 0; s < e.length; s++) {
                        for (a = r = e[s], n = 0; n < i.length; n++) o = i[n], r = r.replace(o, Vt[o]);
                        o = parseInt(Bt[a], 16), t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o]
                    }
                    return t
                }(), Nt.transparent = [0, 0, 0, 0]);
                const e = Nt[t.toLowerCase()];
                return e && {
                    r: e[0],
                    g: e[1],
                    b: e[2],
                    a: 4 === e.length ? e[3] : 255
                }
            }
            const jt = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
            const Ht = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055,
                $t = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);

            function Yt(t, e, i) {
                if (t) {
                    let s = Et(t);
                    s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = It(s), t.r = s[0], t.g = s[1], t.b = s[2]
                }
            }

            function Ut(t, e) {
                return t ? Object.assign(e || {}, t) : t
            }

            function Xt(t) {
                var e = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 255
                };
                return Array.isArray(t) ? t.length >= 3 && (e = {
                    r: t[0],
                    g: t[1],
                    b: t[2],
                    a: 255
                }, t.length > 3 && (e.a = yt(t[3]))) : (e = Ut(t, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                })).a = yt(e.a), e
            }

            function qt(t) {
                return "r" === t.charAt(0) ? function (t) {
                    const e = jt.exec(t);
                    let i, s, n, o = 255;
                    if (e) {
                        if (e[7] !== i) {
                            const t = +e[7];
                            o = e[8] ? _t(t) : xt(255 * t, 0, 255)
                        }
                        return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? _t(i) : xt(i, 0, 255)), s = 255 & (e[4] ? _t(s) : xt(s, 0, 255)), n = 255 & (e[6] ? _t(n) : xt(n, 0, 255)), {
                            r: i,
                            g: s,
                            b: n,
                            a: o
                        }
                    }
                }(t) : Ft(t)
            }
            class Kt {
                constructor(t) {
                    if (t instanceof Kt) return t;
                    const e = typeof t;
                    let i;
                    var s, n, o;
                    "object" === e ? i = Xt(t) : "string" === e && (o = (s = t).length, "#" === s[0] && (4 === o || 5 === o ? n = {
                        r: 255 & 17 * Mt[s[1]],
                        g: 255 & 17 * Mt[s[2]],
                        b: 255 & 17 * Mt[s[3]],
                        a: 5 === o ? 17 * Mt[s[4]] : 255
                    } : 7 !== o && 9 !== o || (n = {
                        r: Mt[s[1]] << 4 | Mt[s[2]],
                        g: Mt[s[3]] << 4 | Mt[s[4]],
                        b: Mt[s[5]] << 4 | Mt[s[6]],
                        a: 9 === o ? Mt[s[7]] << 4 | Mt[s[8]] : 255
                    })), i = n || Wt(t) || qt(t)), this._rgb = i, this._valid = !!i
                }
                get valid() {
                    return this._valid
                }
                get rgb() {
                    var t = Ut(this._rgb);
                    return t && (t.a = vt(t.a)), t
                }
                set rgb(t) {
                    this._rgb = Xt(t)
                }
                rgbString() {
                    return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${vt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;
                    var t
                }
                hexString() {
                    return this._valid ? Ot(this._rgb) : void 0
                }
                hslString() {
                    return this._valid ? function (t) {
                        if (!t) return;
                        const e = Et(t),
                            i = e[0],
                            s = wt(e[1]),
                            n = wt(e[2]);
                        return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${vt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`
                    }(this._rgb) : void 0
                }
                mix(t, e) {
                    if (t) {
                        const i = this.rgb,
                            s = t.rgb;
                        let n;
                        const o = e === n ? .5 : e,
                            a = 2 * o - 1,
                            r = i.a - s.a,
                            l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;
                        n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i
                    }
                    return this
                }
                interpolate(t, e) {
                    return t && (this._rgb = function (t, e, i) {
                        const s = $t(vt(t.r)),
                            n = $t(vt(t.g)),
                            o = $t(vt(t.b));
                        return {
                            r: yt(Ht(s + i * ($t(vt(e.r)) - s))),
                            g: yt(Ht(n + i * ($t(vt(e.g)) - n))),
                            b: yt(Ht(o + i * ($t(vt(e.b)) - o))),
                            a: t.a + i * (e.a - t.a)
                        }
                    }(this._rgb, t._rgb, e)), this
                }
                clone() {
                    return new Kt(this.rgb)
                }
                alpha(t) {
                    return this._rgb.a = yt(t), this
                }
                clearer(t) {
                    return this._rgb.a *= 1 - t, this
                }
                greyscale() {
                    const t = this._rgb,
                        e = bt(.3 * t.r + .59 * t.g + .11 * t.b);
                    return t.r = t.g = t.b = e, this
                }
                opaquer(t) {
                    return this._rgb.a *= 1 + t, this
                }
                negate() {
                    const t = this._rgb;
                    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
                }
                lighten(t) {
                    return Yt(this._rgb, 2, t), this
                }
                darken(t) {
                    return Yt(this._rgb, 2, -t), this
                }
                saturate(t) {
                    return Yt(this._rgb, 1, t), this
                }
                desaturate(t) {
                    return Yt(this._rgb, 1, -t), this
                }
                rotate(t) {
                    return function (t, e) {
                        var i = Et(t);
                        i[0] = zt(i[0] + e), i = It(i), t.r = i[0], t.g = i[1], t.b = i[2]
                    }(this._rgb, t), this
                }
            }

            function Gt(t) {
                return new Kt(t)
            }

            function Zt(t) {
                if (t && "object" == typeof t) {
                    const e = t.toString();
                    return "[object CanvasPattern]" === e || "[object CanvasGradient]" === e
                }
                return !1
            }

            function Jt(t) {
                return Zt(t) ? t : Gt(t)
            }

            function Qt(t) {
                return Zt(t) ? t : Gt(t).saturate(.5).darken(.1).hexString()
            }
            const te = Object.create(null),
                ee = Object.create(null);

            function ie(t, e) {
                if (!e) return t;
                const i = e.split(".");
                for (let e = 0, s = i.length; e < s; ++e) {
                    const s = i[e];
                    t = t[s] || (t[s] = Object.create(null))
                }
                return t
            }

            function se(t, e, i) {
                return "string" == typeof e ? m(ie(t, e), i) : m(ie(t, ""), e)
            }
            var ne = new class {
                constructor(t) {
                    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
                        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                        size: 12,
                        style: "normal",
                        lineHeight: 1.2,
                        weight: null
                    }, this.hover = {}, this.hoverBackgroundColor = (t, e) => Qt(e.backgroundColor), this.hoverBorderColor = (t, e) => Qt(e.borderColor), this.hoverColor = (t, e) => Qt(e.color), this.indexAxis = "x", this.interaction = {
                        mode: "nearest",
                        intersect: !0,
                        includeInvisible: !1
                    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t)
                }
                set(t, e) {
                    return se(this, t, e)
                }
                get(t) {
                    return ie(this, t)
                }
                describe(t, e) {
                    return se(ee, t, e)
                }
                override(t, e) {
                    return se(te, t, e)
                }
                route(t, e, i, s) {
                    const o = ie(this, t),
                        a = ie(this, i),
                        l = "_" + e;
                    Object.defineProperties(o, {
                        [l]: {
                            value: o[e],
                            writable: !0
                        },
                        [e]: {
                            enumerable: !0,
                            get() {
                                const t = this[l],
                                    e = a[s];
                                return n(t) ? Object.assign({}, e, t) : r(t, e)
                            },
                            set(t) {
                                this[l] = t
                            }
                        }
                    })
                }
            }({
                _scriptable: t => !t.startsWith("on"),
                _indexable: t => "events" !== t,
                hover: {
                    _fallback: "interaction"
                },
                interaction: {
                    _scriptable: !1,
                    _indexable: !1
                }
            });

            function oe() {
                return "undefined" != typeof window && "undefined" != typeof document
            }

            function ae(t) {
                let e = t.parentNode;
                return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
            }

            function re(t, e, i) {
                let s;
                return "string" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf("%") && (s = s / 100 * e.parentNode[i])) : s = t, s
            }
            const le = t => window.getComputedStyle(t, null);

            function he(t, e) {
                return le(t).getPropertyValue(e)
            }
            const ce = ["top", "right", "bottom", "left"];

            function de(t, e, i) {
                const s = {};
                i = i ? "-" + i : "";
                for (let n = 0; n < 4; n++) {
                    const o = ce[n];
                    s[o] = parseFloat(t[e + "-" + o + i]) || 0
                }
                return s.width = s.left + s.right, s.height = s.top + s.bottom, s
            }

            function ue(t, e) {
                if ("native" in t) return t;
                const {
                    canvas: i,
                    currentDevicePixelRatio: s
                } = e, n = le(i), o = "border-box" === n.boxSizing, a = de(n, "padding"), r = de(n, "border", "width"), {
                    x: l,
                    y: h,
                    box: c
                } = function (t, e) {
                    const i = t.touches,
                        s = i && i.length ? i[0] : t,
                        {
                            offsetX: n,
                            offsetY: o
                        } = s;
                    let a, r, l = !1;
                    if (((t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(n, o, t.target)) a = n, r = o;
                    else {
                        const t = e.getBoundingClientRect();
                        a = s.clientX - t.left, r = s.clientY - t.top, l = !0
                    }
                    return {
                        x: a,
                        y: r,
                        box: l
                    }
                }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);
                let {
                    width: f,
                    height: g
                } = e;
                return o && (f -= a.width + r.width, g -= a.height + r.height), {
                    x: Math.round((l - d) / f * i.width / s),
                    y: Math.round((h - u) / g * i.height / s)
                }
            }
            const fe = t => Math.round(10 * t) / 10;

            function ge(t, e, i, s) {
                const n = le(t),
                    o = de(n, "margin"),
                    a = re(n.maxWidth, t, "clientWidth") || A,
                    r = re(n.maxHeight, t, "clientHeight") || A,
                    l = function (t, e, i) {
                        let s, n;
                        if (void 0 === e || void 0 === i) {
                            const o = ae(t);
                            if (o) {
                                const t = o.getBoundingClientRect(),
                                    a = le(o),
                                    r = de(a, "border", "width"),
                                    l = de(a, "padding");
                                e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = re(a.maxWidth, o, "clientWidth"), n = re(a.maxHeight, o, "clientHeight")
                            } else e = t.clientWidth, i = t.clientHeight
                        }
                        return {
                            width: e,
                            height: i,
                            maxWidth: s || A,
                            maxHeight: n || A
                        }
                    }(t, e, i);
                let {
                    width: h,
                    height: c
                } = l;
                if ("content-box" === n.boxSizing) {
                    const t = de(n, "border", "width"),
                        e = de(n, "padding");
                    h -= e.width + t.width, c -= e.height + t.height
                }
                return h = Math.max(0, h - o.width), c = Math.max(0, s ? Math.floor(h / s) : c - o.height), h = fe(Math.min(h, a, l.maxWidth)), c = fe(Math.min(c, r, l.maxHeight)), h && !c && (c = fe(h / 2)), {
                    width: h,
                    height: c
                }
            }

            function pe(t, e, i) {
                const s = e || 1,
                    n = Math.floor(t.height * s),
                    o = Math.floor(t.width * s);
                t.height = n / s, t.width = o / s;
                const a = t.canvas;
                return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0)
            }
            const me = function () {
                let t = !1;
                try {
                    const e = {
                        get passive() {
                            return t = !0, !1
                        }
                    };
                    window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
                } catch (t) {}
                return t
            }();

            function be(t, e) {
                const i = he(t, e),
                    s = i && i.match(/^(\d+)(\.\d+)?px$/);
                return s ? +s[1] : void 0
            }

            function xe(t) {
                return !t || i(t.size) || i(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
            }

            function _e(t, e, i, s, n) {
                let o = e[n];
                return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s
            }

            function ye(t, e, i, n) {
                let o = (n = n || {}).data = n.data || {},
                    a = n.garbageCollect = n.garbageCollect || [];
                n.font !== e && (o = n.data = {}, a = n.garbageCollect = [], n.font = e), t.save(), t.font = e;
                let r = 0;
                const l = i.length;
                let h, c, d, u, f;
                for (h = 0; h < l; h++)
                    if (u = i[h], null != u && !0 !== s(u)) r = _e(t, o, a, r, u);
                    else if (s(u))
                    for (c = 0, d = u.length; c < d; c++) f = u[c], null == f || s(f) || (r = _e(t, o, a, r, f));
                t.restore();
                const g = a.length / 2;
                if (g > i.length) {
                    for (h = 0; h < g; h++) delete o[a[h]];
                    a.splice(0, g)
                }
                return r
            }

            function ve(t, e, i) {
                const s = t.currentDevicePixelRatio,
                    n = 0 !== i ? Math.max(i / 2, .5) : 0;
                return Math.round((e - n) * s) / s + n
            }

            function we(t, e) {
                (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
            }

            function Me(t, e, i, s) {
                ke(t, e, i, s, null)
            }

            function ke(t, e, i, s, n) {
                let o, a, r, l, h, c;
                const d = e.pointStyle,
                    u = e.rotation,
                    f = e.radius;
                let g = (u || 0) * T;
                if (d && "object" == typeof d && (o = d.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(i, s), t.rotate(g), t.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), void t.restore();
                if (!(isNaN(f) || f <= 0)) {
                    switch (t.beginPath(), d) {
                        default:
                            n ? t.ellipse(i, s, n / 2, f, 0, 0, O) : t.arc(i, s, f, 0, O), t.closePath();
                            break;
                        case "triangle":
                            t.moveTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), t.closePath();
                            break;
                        case "rectRounded":
                            h = .516 * f, l = f - h, a = Math.cos(g + E) * l, r = Math.sin(g + E) * l, t.arc(i - a, s - r, h, g - D, g - L), t.arc(i + r, s - a, h, g - L, g), t.arc(i + a, s + r, h, g, g + L), t.arc(i - r, s + a, h, g + L, g + D), t.closePath();
                            break;
                        case "rect":
                            if (!u) {
                                l = Math.SQRT1_2 * f, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);
                                break
                            }
                            g += E;
                        case "rectRot":
                            a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + r, s - a), t.lineTo(i + a, s + r), t.lineTo(i - r, s + a), t.closePath();
                            break;
                        case "crossRot":
                            g += E;
                        case "cross":
                            a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);
                            break;
                        case "star":
                            a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a), g += E, a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);
                            break;
                        case "line":
                            a = n ? n / 2 : Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);
                            break;
                        case "dash":
                            t.moveTo(i, s), t.lineTo(i + Math.cos(g) * f, s + Math.sin(g) * f)
                    }
                    t.fill(), e.borderWidth > 0 && t.stroke()
                }
            }

            function Se(t, e, i) {
                return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
            }

            function Pe(t, e) {
                t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
            }

            function De(t) {
                t.restore()
            }

            function Oe(t, e, i, s, n) {
                if (!e) return t.lineTo(i.x, i.y);
                if ("middle" === n) {
                    const s = (e.x + i.x) / 2;
                    t.lineTo(s, e.y), t.lineTo(s, i.y)
                } else "after" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
                t.lineTo(i.x, i.y)
            }

            function Ce(t, e, i, s) {
                if (!e) return t.lineTo(i.x, i.y);
                t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)
            }

            function Ae(t, e, n, o, a, r = {}) {
                const l = s(e) ? e : [e],
                    h = r.strokeWidth > 0 && "" !== r.strokeColor;
                let c, d;
                for (t.save(), t.font = a.string, function (t, e) {
                        e.translation && t.translate(e.translation[0], e.translation[1]);
                        i(e.rotation) || t.rotate(e.rotation);
                        e.color && (t.fillStyle = e.color);
                        e.textAlign && (t.textAlign = e.textAlign);
                        e.textBaseline && (t.textBaseline = e.textBaseline)
                    }(t, r), c = 0; c < l.length; ++c) d = l[c], h && (r.strokeColor && (t.strokeStyle = r.strokeColor), i(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, n, o, r.maxWidth)), t.fillText(d, n, o, r.maxWidth), Te(t, n, o, d, r), o += a.lineHeight;
                t.restore()
            }

            function Te(t, e, i, s, n) {
                if (n.strikethrough || n.underline) {
                    const o = t.measureText(s),
                        a = e - o.actualBoundingBoxLeft,
                        r = e + o.actualBoundingBoxRight,
                        l = i - o.actualBoundingBoxAscent,
                        h = i + o.actualBoundingBoxDescent,
                        c = n.strikethrough ? (l + h) / 2 : h;
                    t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke()
                }
            }

            function Le(t, e) {
                const {
                    x: i,
                    y: s,
                    w: n,
                    h: o,
                    radius: a
                } = e;
                t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, -L, D, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, D, L, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, L, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -L, !0), t.lineTo(i + a.topLeft, s)
            }

            function Ee(t, e = [""], i = t, s, n = (() => t[0])) {
                M(s) || (s = $e("_fallback", t));
                const o = {
                    [Symbol.toStringTag]: "Object",
                    _cacheable: !0,
                    _scopes: t,
                    _rootScopes: i,
                    _fallback: s,
                    _getTarget: n,
                    override: n => Ee([n, ...t], e, i, s)
                };
                return new Proxy(o, {
                    deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0),
                    get: (i, s) => Ve(i, s, (() => function (t, e, i, s) {
                        let n;
                        for (const o of e)
                            if (n = $e(ze(o, t), i), M(n)) return Fe(t, n) ? je(i, s, t, n) : n
                    }(s, e, t, i))),
                    getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
                    getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),
                    has: (t, e) => Ye(t).includes(e),
                    ownKeys: t => Ye(t),
                    set(t, e, i) {
                        const s = t._storage || (t._storage = n());
                        return t[e] = s[e] = i, delete t._keys, !0
                    }
                })
            }

            function Re(t, e, i, o) {
                const a = {
                    _cacheable: !1,
                    _proxy: t,
                    _context: e,
                    _subProxy: i,
                    _stack: new Set,
                    _descriptors: Ie(t, o),
                    setContext: e => Re(t, e, i, o),
                    override: s => Re(t.override(s), e, i, o)
                };
                return new Proxy(a, {
                    deleteProperty: (e, i) => (delete e[i], delete t[i], !0),
                    get: (t, e, i) => Ve(t, e, (() => function (t, e, i) {
                        const {
                            _proxy: o,
                            _context: a,
                            _subProxy: r,
                            _descriptors: l
                        } = t;
                        let h = o[e];
                        k(h) && l.isScriptable(e) && (h = function (t, e, i, s) {
                            const {
                                _proxy: n,
                                _context: o,
                                _subProxy: a,
                                _stack: r
                            } = i;
                            if (r.has(t)) throw new Error("Recursion detected: " + Array.from(r).join("->") + "->" + t);
                            r.add(t), e = e(o, a || s), r.delete(t), Fe(t, e) && (e = je(n._scopes, n, t, e));
                            return e
                        }(e, h, t, i));
                        s(h) && h.length && (h = function (t, e, i, s) {
                            const {
                                _proxy: o,
                                _context: a,
                                _subProxy: r,
                                _descriptors: l
                            } = i;
                            if (M(a.index) && s(t)) e = e[a.index % e.length];
                            else if (n(e[0])) {
                                const i = e,
                                    s = o._scopes.filter((t => t !== i));
                                e = [];
                                for (const n of i) {
                                    const i = je(s, o, t, n);
                                    e.push(Re(i, a, r && r[t], l))
                                }
                            }
                            return e
                        }(e, h, t, l.isIndexable));
                        Fe(e, h) && (h = Re(h, a, r && r[e], l));
                        return h
                    }(t, e, i))),
                    getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? {
                        enumerable: !0,
                        configurable: !0
                    } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),
                    getPrototypeOf: () => Reflect.getPrototypeOf(t),
                    has: (e, i) => Reflect.has(t, i),
                    ownKeys: () => Reflect.ownKeys(t),
                    set: (e, i, s) => (t[i] = s, delete e[i], !0)
                })
            }

            function Ie(t, e = {
                scriptable: !0,
                indexable: !0
            }) {
                const {
                    _scriptable: i = e.scriptable,
                    _indexable: s = e.indexable,
                    _allKeys: n = e.allKeys
                } = t;
                return {
                    allKeys: n,
                    scriptable: i,
                    indexable: s,
                    isScriptable: k(i) ? i : () => i,
                    isIndexable: k(s) ? s : () => s
                }
            }
            const ze = (t, e) => t ? t + w(e) : e,
                Fe = (t, e) => n(e) && "adapters" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);

            function Ve(t, e, i) {
                if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];
                const s = i();
                return t[e] = s, s
            }

            function Be(t, e, i) {
                return k(t) ? t(e, i) : t
            }
            const Ne = (t, e) => !0 === t ? e : "string" == typeof t ? y(e, t) : void 0;

            function We(t, e, i, s, n) {
                for (const o of e) {
                    const e = Ne(i, o);
                    if (e) {
                        t.add(e);
                        const o = Be(e._fallback, i, n);
                        if (M(o) && o !== i && o !== s) return o
                    } else if (!1 === e && M(s) && i !== s) return null
                }
                return !1
            }

            function je(t, e, i, o) {
                const a = e._rootScopes,
                    r = Be(e._fallback, i, o),
                    l = [...t, ...a],
                    h = new Set;
                h.add(o);
                let c = He(h, l, i, r || i, o);
                return null !== c && ((!M(r) || r === i || (c = He(h, l, r, c, o), null !== c)) && Ee(Array.from(h), [""], a, r, (() => function (t, e, i) {
                    const o = t._getTarget();
                    e in o || (o[e] = {});
                    const a = o[e];
                    if (s(a) && n(i)) return i;
                    return a
                }(e, i, o))))
            }

            function He(t, e, i, s, n) {
                for (; i;) i = We(t, e, i, s, n);
                return i
            }

            function $e(t, e) {
                for (const i of e) {
                    if (!i) continue;
                    const e = i[t];
                    if (M(e)) return e
                }
            }

            function Ye(t) {
                let e = t._keys;
                return e || (e = t._keys = function (t) {
                    const e = new Set;
                    for (const i of t)
                        for (const t of Object.keys(i).filter((t => !t.startsWith("_")))) e.add(t);
                    return Array.from(e)
                }(t._scopes)), e
            }

            function Ue(t, e, i, s) {
                const {
                    iScale: n
                } = t, {
                    key: o = "r"
                } = this._parsing, a = new Array(s);
                let r, l, h, c;
                for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
                    r: n.parse(y(c, o), h)
                };
                return a
            }
            const Xe = Number.EPSILON || 1e-14,
                qe = (t, e) => e < t.length && !t[e].skip && t[e],
                Ke = t => "x" === t ? "y" : "x";

            function Ge(t, e, i, s) {
                const n = t.skip ? e : t,
                    o = e,
                    a = i.skip ? e : i,
                    r = X(o, n),
                    l = X(a, o);
                let h = r / (r + l),
                    c = l / (r + l);
                h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;
                const d = s * h,
                    u = s * c;
                return {
                    previous: {
                        x: o.x - d * (a.x - n.x),
                        y: o.y - d * (a.y - n.y)
                    },
                    next: {
                        x: o.x + u * (a.x - n.x),
                        y: o.y + u * (a.y - n.y)
                    }
                }
            }

            function Ze(t, e = "x") {
                const i = Ke(e),
                    s = t.length,
                    n = Array(s).fill(0),
                    o = Array(s);
                let a, r, l, h = qe(t, 0);
                for (a = 0; a < s; ++a)
                    if (r = l, l = h, h = qe(t, a + 1), l) {
                        if (h) {
                            const t = h[e] - l[e];
                            n[a] = 0 !== t ? (h[i] - l[i]) / t : 0
                        }
                        o[a] = r ? h ? z(n[a - 1]) !== z(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a]
                    }!
                function (t, e, i) {
                    const s = t.length;
                    let n, o, a, r, l, h = qe(t, 0);
                    for (let c = 0; c < s - 1; ++c) l = h, h = qe(t, c + 1), l && h && (N(e[c], 0, Xe) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])))
                }(t, n, o),
                function (t, e, i = "x") {
                    const s = Ke(i),
                        n = t.length;
                    let o, a, r, l = qe(t, 0);
                    for (let h = 0; h < n; ++h) {
                        if (a = r, r = l, l = qe(t, h + 1), !r) continue;
                        const n = r[i],
                            c = r[s];
                        a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h])
                    }
                }(t, o, e)
            }

            function Je(t, e, i) {
                return Math.max(Math.min(t, i), e)
            }

            function Qe(t, e, i, s, n) {
                let o, a, r, l;
                if (e.spanGaps && (t = t.filter((t => !t.skip))), "monotone" === e.cubicInterpolationMode) Ze(t, n);
                else {
                    let i = s ? t[t.length - 1] : t[0];
                    for (o = 0, a = t.length; o < a; ++o) r = t[o], l = Ge(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r
                }
                e.capBezierPoints && function (t, e) {
                    let i, s, n, o, a, r = Se(t[0], e);
                    for (i = 0, s = t.length; i < s; ++i) a = o, o = r, r = i < s - 1 && Se(t[i + 1], e), o && (n = t[i], a && (n.cp1x = Je(n.cp1x, e.left, e.right), n.cp1y = Je(n.cp1y, e.top, e.bottom)), r && (n.cp2x = Je(n.cp2x, e.left, e.right), n.cp2y = Je(n.cp2y, e.top, e.bottom)))
                }(t, i)
            }
            const ti = t => 0 === t || 1 === t,
                ei = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i),
                ii = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1,
                si = {
                    linear: t => t,
                    easeInQuad: t => t * t,
                    easeOutQuad: t => -t * (t - 2),
                    easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
                    easeInCubic: t => t * t * t,
                    easeOutCubic: t => (t -= 1) * t * t + 1,
                    easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
                    easeInQuart: t => t * t * t * t,
                    easeOutQuart: t => -((t -= 1) * t * t * t - 1),
                    easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
                    easeInQuint: t => t * t * t * t * t,
                    easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
                    easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
                    easeInSine: t => 1 - Math.cos(t * L),
                    easeOutSine: t => Math.sin(t * L),
                    easeInOutSine: t => -.5 * (Math.cos(D * t) - 1),
                    easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
                    easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
                    easeInOutExpo: t => ti(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
                    easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
                    easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
                    easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
                    easeInElastic: t => ti(t) ? t : ei(t, .075, .3),
                    easeOutElastic: t => ti(t) ? t : ii(t, .075, .3),
                    easeInOutElastic(t) {
                        const e = .1125;
                        return ti(t) ? t : t < .5 ? .5 * ei(2 * t, e, .45) : .5 + .5 * ii(2 * t - 1, e, .45)
                    },
                    easeInBack(t) {
                        const e = 1.70158;
                        return t * t * ((e + 1) * t - e)
                    },
                    easeOutBack(t) {
                        const e = 1.70158;
                        return (t -= 1) * t * ((e + 1) * t + e) + 1
                    },
                    easeInOutBack(t) {
                        let e = 1.70158;
                        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
                    },
                    easeInBounce: t => 1 - si.easeOutBounce(1 - t),
                    easeOutBounce(t) {
                        const e = 7.5625,
                            i = 2.75;
                        return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375
                    },
                    easeInOutBounce: t => t < .5 ? .5 * si.easeInBounce(2 * t) : .5 * si.easeOutBounce(2 * t - 1) + .5
                };

            function ni(t, e, i, s) {
                return {
                    x: t.x + i * (e.x - t.x),
                    y: t.y + i * (e.y - t.y)
                }
            }

            function oi(t, e, i, s) {
                return {
                    x: t.x + i * (e.x - t.x),
                    y: "middle" === s ? i < .5 ? t.y : e.y : "after" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y
                }
            }

            function ai(t, e, i, s) {
                const n = {
                        x: t.cp2x,
                        y: t.cp2y
                    },
                    o = {
                        x: e.cp1x,
                        y: e.cp1y
                    },
                    a = ni(t, n, i),
                    r = ni(n, o, i),
                    l = ni(o, e, i),
                    h = ni(a, r, i),
                    c = ni(r, l, i);
                return ni(h, c, i)
            }
            const ri = new Map;

            function li(t, e, i) {
                return function (t, e) {
                    e = e || {};
                    const i = t + JSON.stringify(e);
                    let s = ri.get(i);
                    return s || (s = new Intl.NumberFormat(t, e), ri.set(i, s)), s
                }(e, i).format(t)
            }
            const hi = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),
                ci = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);

            function di(t, e) {
                const i = ("" + t).match(hi);
                if (!i || "normal" === i[1]) return 1.2 * e;
                switch (t = +i[2], i[3]) {
                    case "px":
                        return t;
                    case "%":
                        t /= 100
                }
                return e * t
            }

            function ui(t, e) {
                const i = {},
                    s = n(e),
                    o = s ? Object.keys(e) : e,
                    a = n(t) ? s ? i => r(t[i], t[e[i]]) : e => t[e] : () => t;
                for (const t of o) i[t] = +a(t) || 0;
                return i
            }

            function fi(t) {
                return ui(t, {
                    top: "y",
                    right: "x",
                    bottom: "y",
                    left: "x"
                })
            }

            function gi(t) {
                return ui(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
            }

            function pi(t) {
                const e = fi(t);
                return e.width = e.left + e.right, e.height = e.top + e.bottom, e
            }

            function mi(t, e) {
                t = t || {}, e = e || ne.font;
                let i = r(t.size, e.size);
                "string" == typeof i && (i = parseInt(i, 10));
                let s = r(t.style, e.style);
                s && !("" + s).match(ci) && (console.warn('Invalid font style specified: "' + s + '"'), s = "");
                const n = {
                    family: r(t.family, e.family),
                    lineHeight: di(r(t.lineHeight, e.lineHeight), i),
                    size: i,
                    style: s,
                    weight: r(t.weight, e.weight),
                    string: ""
                };
                return n.string = xe(n), n
            }

            function bi(t, e, i, n) {
                let o, a, r, l = !0;
                for (o = 0, a = t.length; o < a; ++o)
                    if (r = t[o], void 0 !== r && (void 0 !== e && "function" == typeof r && (r = r(e), l = !1), void 0 !== i && s(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return n && !l && (n.cacheable = !1), r
            }

            function xi(t, e, i) {
                const {
                    min: s,
                    max: n
                } = t, o = h(e, (n - s) / 2), a = (t, e) => i && 0 === t ? 0 : t + e;
                return {
                    min: a(s, -Math.abs(o)),
                    max: a(n, o)
                }
            }

            function _i(t, e) {
                return Object.assign(Object.create(t), e)
            }

            function yi(t, e, i) {
                return t ? function (t, e) {
                    return {
                        x: i => t + t + e - i,
                        setWidth(t) {
                            e = t
                        },
                        textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
                        xPlus: (t, e) => t - e,
                        leftForLtr: (t, e) => t - e
                    }
                }(e, i) : {
                    x: t => t,
                    setWidth(t) {},
                    textAlign: t => t,
                    xPlus: (t, e) => t + e,
                    leftForLtr: (t, e) => t
                }
            }

            function vi(t, e) {
                let i, s;
                "ltr" !== e && "rtl" !== e || (i = t.canvas.style, s = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = s)
            }

            function wi(t, e) {
                void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
            }

            function Mi(t) {
                return "angle" === t ? {
                    between: G,
                    compare: q,
                    normalize: K
                } : {
                    between: Q,
                    compare: (t, e) => t - e,
                    normalize: t => t
                }
            }

            function ki({
                start: t,
                end: e,
                count: i,
                loop: s,
                style: n
            }) {
                return {
                    start: t % i,
                    end: e % i,
                    loop: s && (e - t + 1) % i == 0,
                    style: n
                }
            }

            function Si(t, e, i) {
                if (!i) return [t];
                const {
                    property: s,
                    start: n,
                    end: o
                } = i, a = e.length, {
                    compare: r,
                    between: l,
                    normalize: h
                } = Mi(s), {
                    start: c,
                    end: d,
                    loop: u,
                    style: f
                } = function (t, e, i) {
                    const {
                        property: s,
                        start: n,
                        end: o
                    } = i, {
                        between: a,
                        normalize: r
                    } = Mi(s), l = e.length;
                    let h, c, {
                        start: d,
                        end: u,
                        loop: f
                    } = t;
                    if (f) {
                        for (d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h) d--, u--;
                        d %= l, u %= l
                    }
                    return u < d && (u += l), {
                        start: d,
                        end: u,
                        loop: f,
                        style: t.style
                    }
                }(t, e, i), g = [];
                let p, m, b, x = !1,
                    _ = null;
                const y = () => x || l(n, b, p) && 0 !== r(n, b),
                    v = () => !x || 0 === r(o, p) || l(o, b, p);
                for (let t = c, i = c; t <= d; ++t) m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(ki({
                    start: _,
                    end: t,
                    loop: u,
                    count: a,
                    style: f
                })), _ = null), i = t, b = p));
                return null !== _ && g.push(ki({
                    start: _,
                    end: d,
                    loop: u,
                    count: a,
                    style: f
                })), g
            }

            function Pi(t, e) {
                const i = [],
                    s = t.segments;
                for (let n = 0; n < s.length; n++) {
                    const o = Si(s[n], t.points, e);
                    o.length && i.push(...o)
                }
                return i
            }

            function Di(t, e) {
                const i = t.points,
                    s = t.options.spanGaps,
                    n = i.length;
                if (!n) return [];
                const o = !!t._loop,
                    {
                        start: a,
                        end: r
                    } = function (t, e, i, s) {
                        let n = 0,
                            o = e - 1;
                        if (i && !s)
                            for (; n < e && !t[n].skip;) n++;
                        for (; n < e && t[n].skip;) n++;
                        for (n %= e, i && (o += n); o > n && t[o % e].skip;) o--;
                        return o %= e, {
                            start: n,
                            end: o
                        }
                    }(i, n, o, s);
                if (!0 === s) return Oi(t, [{
                    start: a,
                    end: r,
                    loop: o
                }], i, e);
                return Oi(t, function (t, e, i, s) {
                    const n = t.length,
                        o = [];
                    let a, r = e,
                        l = t[e];
                    for (a = e + 1; a <= i; ++a) {
                        const i = t[a % n];
                        i.skip || i.stop ? l.skip || (s = !1, o.push({
                            start: e % n,
                            end: (a - 1) % n,
                            loop: s
                        }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i
                    }
                    return null !== r && o.push({
                        start: e % n,
                        end: r % n,
                        loop: s
                    }), o
                }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e)
            }

            function Oi(t, e, i, s) {
                return s && s.setContext && i ? function (t, e, i, s) {
                    const n = t._chart.getContext(),
                        o = Ci(t.options),
                        {
                            _datasetIndex: a,
                            options: {
                                spanGaps: r
                            }
                        } = t,
                        l = i.length,
                        h = [];
                    let c = o,
                        d = e[0].start,
                        u = d;

                    function f(t, e, s, n) {
                        const o = r ? -1 : 1;
                        if (t !== e) {
                            for (t += l; i[t % l].skip;) t -= o;
                            for (; i[e % l].skip;) e += o;
                            t % l != e % l && (h.push({
                                start: t % l,
                                end: e % l,
                                loop: s,
                                style: n
                            }), c = n, d = e % l)
                        }
                    }
                    for (const t of e) {
                        d = r ? d : t.start;
                        let e, o = i[d % l];
                        for (u = d + 1; u <= t.end; u++) {
                            const r = i[u % l];
                            e = Ci(s.setContext(_i(n, {
                                type: "segment",
                                p0: o,
                                p1: r,
                                p0DataIndex: (u - 1) % l,
                                p1DataIndex: u % l,
                                datasetIndex: a
                            }))), Ai(e, c) && f(d, u - 1, t.loop, c), o = r, c = e
                        }
                        d < u - 1 && f(d, u - 1, t.loop, c)
                    }
                    return h
                }(t, e, i, s) : e
            }

            function Ci(t) {
                return {
                    backgroundColor: t.backgroundColor,
                    borderCapStyle: t.borderCapStyle,
                    borderDash: t.borderDash,
                    borderDashOffset: t.borderDashOffset,
                    borderJoinStyle: t.borderJoinStyle,
                    borderWidth: t.borderWidth,
                    borderColor: t.borderColor
                }
            }

            function Ai(t, e) {
                return e && JSON.stringify(t) !== JSON.stringify(e)
            }
            var Ti = Object.freeze({
                __proto__: null,
                easingEffects: si,
                isPatternOrGradient: Zt,
                color: Jt,
                getHoverColor: Qt,
                noop: t,
                uid: e,
                isNullOrUndef: i,
                isArray: s,
                isObject: n,
                isFinite: o,
                finiteOrDefault: a,
                valueOrDefault: r,
                toPercentage: l,
                toDimension: h,
                callback: c,
                each: d,
                _elementsEqual: u,
                clone: f,
                _merger: p,
                merge: m,
                mergeIf: b,
                _mergerIf: x,
                _deprecated: function (t, e, i, s) {
                    void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + s + '" instead')
                },
                resolveObjectKey: y,
                _splitKey: v,
                _capitalize: w,
                defined: M,
                isFunction: k,
                setsEqual: S,
                _isClickEvent: P,
                toFontString: xe,
                _measureText: _e,
                _longestText: ye,
                _alignPixel: ve,
                clearCanvas: we,
                drawPoint: Me,
                drawPointLegend: ke,
                _isPointInArea: Se,
                clipArea: Pe,
                unclipArea: De,
                _steppedLineTo: Oe,
                _bezierCurveTo: Ce,
                renderText: Ae,
                addRoundedRectPath: Le,
                _lookup: tt,
                _lookupByKey: et,
                _rlookupByKey: it,
                _filterBetween: st,
                listenArrayEvents: ot,
                unlistenArrayEvents: at,
                _arrayUnique: rt,
                _createResolver: Ee,
                _attachContext: Re,
                _descriptors: Ie,
                _parseObjectDataRadialScale: Ue,
                splineCurve: Ge,
                splineCurveMonotone: Ze,
                _updateBezierControlPoints: Qe,
                _isDomSupported: oe,
                _getParentNode: ae,
                getStyle: he,
                getRelativePosition: ue,
                getMaximumSize: ge,
                retinaScale: pe,
                supportsEventListenerOptions: me,
                readUsedSize: be,
                fontString: function (t, e, i) {
                    return e + " " + t + "px " + i
                },
                requestAnimFrame: lt,
                throttled: ht,
                debounce: ct,
                _toLeftRightCenter: dt,
                _alignStartEnd: ut,
                _textX: ft,
                _getStartAndCountOfVisiblePoints: gt,
                _scaleRangesChanged: pt,
                _pointInLine: ni,
                _steppedInterpolation: oi,
                _bezierInterpolation: ai,
                formatNumber: li,
                toLineHeight: di,
                _readValueToProps: ui,
                toTRBL: fi,
                toTRBLCorners: gi,
                toPadding: pi,
                toFont: mi,
                resolve: bi,
                _addGrace: xi,
                createContext: _i,
                PI: D,
                TAU: O,
                PITAU: C,
                INFINITY: A,
                RAD_PER_DEG: T,
                HALF_PI: L,
                QUARTER_PI: E,
                TWO_THIRDS_PI: R,
                log10: I,
                sign: z,
                niceNum: F,
                _factorize: V,
                isNumber: B,
                almostEquals: N,
                almostWhole: W,
                _setMinAndMaxByKey: j,
                toRadians: H,
                toDegrees: $,
                _decimalPlaces: Y,
                getAngleFromPoint: U,
                distanceBetweenPoints: X,
                _angleDiff: q,
                _normalizeAngle: K,
                _angleBetween: G,
                _limitValue: Z,
                _int16Range: J,
                _isBetween: Q,
                getRtlAdapter: yi,
                overrideTextDirection: vi,
                restoreTextDirection: wi,
                _boundSegment: Si,
                _boundSegments: Pi,
                _computeSegments: Di
            });

            function Li(t, e, i, s) {
                const {
                    controller: n,
                    data: o,
                    _sorted: a
                } = t, r = n._cachedMeta.iScale;
                if (r && e === r.axis && "r" !== e && a && o.length) {
                    const t = r._reversePixels ? it : et;
                    if (!s) return t(o, e, i);
                    if (n._sharedOptions) {
                        const s = o[0],
                            n = "function" == typeof s.getRange && s.getRange(e);
                        if (n) {
                            const s = t(o, e, i - n),
                                a = t(o, e, i + n);
                            return {
                                lo: s.lo,
                                hi: a.hi
                            }
                        }
                    }
                }
                return {
                    lo: 0,
                    hi: o.length - 1
                }
            }

            function Ei(t, e, i, s, n) {
                const o = t.getSortedVisibleDatasetMetas(),
                    a = i[e];
                for (let t = 0, i = o.length; t < i; ++t) {
                    const {
                        index: i,
                        data: r
                    } = o[t], {
                        lo: l,
                        hi: h
                    } = Li(o[t], e, a, n);
                    for (let t = l; t <= h; ++t) {
                        const e = r[t];
                        e.skip || s(e, i, t)
                    }
                }
            }

            function Ri(t, e, i, s, n) {
                const o = [];
                if (!n && !t.isPointInArea(e)) return o;
                return Ei(t, i, e, (function (i, a, r) {
                    (n || Se(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({
                        element: i,
                        datasetIndex: a,
                        index: r
                    })
                }), !0), o
            }

            function Ii(t, e, i, s, n, o) {
                let a = [];
                const r = function (t) {
                    const e = -1 !== t.indexOf("x"),
                        i = -1 !== t.indexOf("y");
                    return function (t, s) {
                        const n = e ? Math.abs(t.x - s.x) : 0,
                            o = i ? Math.abs(t.y - s.y) : 0;
                        return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2))
                    }
                }(i);
                let l = Number.POSITIVE_INFINITY;
                return Ei(t, i, e, (function (i, h, c) {
                    const d = i.inRange(e.x, e.y, n);
                    if (s && !d) return;
                    const u = i.getCenterPoint(n);
                    if (!(!!o || t.isPointInArea(u)) && !d) return;
                    const f = r(e, u);
                    f < l ? (a = [{
                        element: i,
                        datasetIndex: h,
                        index: c
                    }], l = f) : f === l && a.push({
                        element: i,
                        datasetIndex: h,
                        index: c
                    })
                })), a
            }

            function zi(t, e, i, s, n, o) {
                return o || t.isPointInArea(e) ? "r" !== i || s ? Ii(t, e, i, s, n, o) : function (t, e, i, s) {
                    let n = [];
                    return Ei(t, i, e, (function (t, i, o) {
                        const {
                            startAngle: a,
                            endAngle: r
                        } = t.getProps(["startAngle", "endAngle"], s), {
                            angle: l
                        } = U(t, {
                            x: e.x,
                            y: e.y
                        });
                        G(l, a, r) && n.push({
                            element: t,
                            datasetIndex: i,
                            index: o
                        })
                    })), n
                }(t, e, i, n) : []
            }

            function Fi(t, e, i, s, n) {
                const o = [],
                    a = "x" === i ? "inXRange" : "inYRange";
                let r = !1;
                return Ei(t, i, e, ((t, s, l) => {
                    t[a](e[i], n) && (o.push({
                        element: t,
                        datasetIndex: s,
                        index: l
                    }), r = r || t.inRange(e.x, e.y, n))
                })), s && !r ? [] : o
            }
            var Vi = {
                evaluateInteractionItems: Ei,
                modes: {
                    index(t, e, i, s) {
                        const n = ue(e, t),
                            o = i.axis || "x",
                            a = i.includeInvisible || !1,
                            r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a),
                            l = [];
                        return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t => {
                            const e = r[0].index,
                                i = t.data[e];
                            i && !i.skip && l.push({
                                element: i,
                                datasetIndex: t.index,
                                index: e
                            })
                        })), l) : []
                    },
                    dataset(t, e, i, s) {
                        const n = ue(e, t),
                            o = i.axis || "xy",
                            a = i.includeInvisible || !1;
                        let r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a);
                        if (r.length > 0) {
                            const e = r[0].datasetIndex,
                                i = t.getDatasetMeta(e).data;
                            r = [];
                            for (let t = 0; t < i.length; ++t) r.push({
                                element: i[t],
                                datasetIndex: e,
                                index: t
                            })
                        }
                        return r
                    },
                    point: (t, e, i, s) => Ri(t, ue(e, t), i.axis || "xy", s, i.includeInvisible || !1),
                    nearest(t, e, i, s) {
                        const n = ue(e, t),
                            o = i.axis || "xy",
                            a = i.includeInvisible || !1;
                        return zi(t, n, o, i.intersect, s, a)
                    },
                    x: (t, e, i, s) => Fi(t, ue(e, t), "x", i.intersect, s),
                    y: (t, e, i, s) => Fi(t, ue(e, t), "y", i.intersect, s)
                }
            };
            const Bi = ["left", "top", "right", "bottom"];

            function Ni(t, e) {
                return t.filter((t => t.pos === e))
            }

            function Wi(t, e) {
                return t.filter((t => -1 === Bi.indexOf(t.pos) && t.box.axis === e))
            }

            function ji(t, e) {
                return t.sort(((t, i) => {
                    const s = e ? i : t,
                        n = e ? t : i;
                    return s.weight === n.weight ? s.index - n.index : s.weight - n.weight
                }))
            }

            function Hi(t, e) {
                const i = function (t) {
                        const e = {};
                        for (const i of t) {
                            const {
                                stack: t,
                                pos: s,
                                stackWeight: n
                            } = i;
                            if (!t || !Bi.includes(s)) continue;
                            const o = e[t] || (e[t] = {
                                count: 0,
                                placed: 0,
                                weight: 0,
                                size: 0
                            });
                            o.count++, o.weight += n
                        }
                        return e
                    }(t),
                    {
                        vBoxMaxWidth: s,
                        hBoxMaxHeight: n
                    } = e;
                let o, a, r;
                for (o = 0, a = t.length; o < a; ++o) {
                    r = t[o];
                    const {
                        fullSize: a
                    } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;
                    r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight)
                }
                return i
            }

            function $i(t, e, i, s) {
                return Math.max(t[i], e[i]) + Math.max(t[s], e[s])
            }

            function Yi(t, e) {
                t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
            }

            function Ui(t, e, i, s) {
                const {
                    pos: o,
                    box: a
                } = i, r = t.maxPadding;
                if (!n(o)) {
                    i.size && (t[o] -= i.size);
                    const e = s[i.stack] || {
                        size: 0,
                        count: 1
                    };
                    e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[o] += i.size
                }
                a.getPadding && Yi(r, a.getPadding());
                const l = Math.max(0, e.outerWidth - $i(r, t, "left", "right")),
                    h = Math.max(0, e.outerHeight - $i(r, t, "top", "bottom")),
                    c = l !== t.w,
                    d = h !== t.h;
                return t.w = l, t.h = h, i.horizontal ? {
                    same: c,
                    other: d
                } : {
                    same: d,
                    other: c
                }
            }

            function Xi(t, e) {
                const i = e.maxPadding;

                function s(t) {
                    const s = {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    };
                    return t.forEach((t => {
                        s[t] = Math.max(e[t], i[t])
                    })), s
                }
                return s(t ? ["left", "right"] : ["top", "bottom"])
            }

            function qi(t, e, i, s) {
                const n = [];
                let o, a, r, l, h, c;
                for (o = 0, a = t.length, h = 0; o < a; ++o) {
                    r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, Xi(r.horizontal, e));
                    const {
                        same: a,
                        other: d
                    } = Ui(e, i, r, s);
                    h |= a && n.length, c = c || d, l.fullSize || n.push(r)
                }
                return h && qi(n, e, i, s) || c
            }

            function Ki(t, e, i, s, n) {
                t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n
            }

            function Gi(t, e, i, s) {
                const n = i.padding;
                let {
                    x: o,
                    y: a
                } = e;
                for (const r of t) {
                    const t = r.box,
                        l = s[r.stack] || {
                            count: 1,
                            placed: 0,
                            weight: 1
                        },
                        h = r.stackWeight / l.weight || 1;
                    if (r.horizontal) {
                        const s = e.w * h,
                            o = l.size || t.height;
                        M(l.start) && (a = l.start), t.fullSize ? Ki(t, n.left, a, i.outerWidth - n.right - n.left, o) : Ki(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom
                    } else {
                        const s = e.h * h,
                            a = l.size || t.width;
                        M(l.start) && (o = l.start), t.fullSize ? Ki(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : Ki(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right
                    }
                }
                e.x = o, e.y = a
            }
            ne.set("layout", {
                autoPadding: !0,
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            });
            var Zi = {
                addBox(t, e) {
                    t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () {
                        return [{
                            z: 0,
                            draw(t) {
                                e.draw(t)
                            }
                        }]
                    }, t.boxes.push(e)
                },
                removeBox(t, e) {
                    const i = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== i && t.boxes.splice(i, 1)
                },
                configure(t, e, i) {
                    e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
                },
                update(t, e, i, s) {
                    if (!t) return;
                    const n = pi(t.options.layout.padding),
                        o = Math.max(e - n.width, 0),
                        a = Math.max(i - n.height, 0),
                        r = function (t) {
                            const e = function (t) {
                                    const e = [];
                                    let i, s, n, o, a, r;
                                    for (i = 0, s = (t || []).length; i < s; ++i) n = t[i], ({
                                        position: o,
                                        options: {
                                            stack: a,
                                            stackWeight: r = 1
                                        }
                                    } = n), e.push({
                                        index: i,
                                        box: n,
                                        pos: o,
                                        horizontal: n.isHorizontal(),
                                        weight: n.weight,
                                        stack: a && o + a,
                                        stackWeight: r
                                    });
                                    return e
                                }(t),
                                i = ji(e.filter((t => t.box.fullSize)), !0),
                                s = ji(Ni(e, "left"), !0),
                                n = ji(Ni(e, "right")),
                                o = ji(Ni(e, "top"), !0),
                                a = ji(Ni(e, "bottom")),
                                r = Wi(e, "x"),
                                l = Wi(e, "y");
                            return {
                                fullSize: i,
                                leftAndTop: s.concat(o),
                                rightAndBottom: n.concat(l).concat(a).concat(r),
                                chartArea: Ni(e, "chartArea"),
                                vertical: s.concat(n).concat(l),
                                horizontal: o.concat(a).concat(r)
                            }
                        }(t.boxes),
                        l = r.vertical,
                        h = r.horizontal;
                    d(t.boxes, (t => {
                        "function" == typeof t.beforeLayout && t.beforeLayout()
                    }));
                    const c = l.reduce(((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1), 0) || 1,
                        u = Object.freeze({
                            outerWidth: e,
                            outerHeight: i,
                            padding: n,
                            availableWidth: o,
                            availableHeight: a,
                            vBoxMaxWidth: o / 2 / c,
                            hBoxMaxHeight: a / 2
                        }),
                        f = Object.assign({}, n);
                    Yi(f, pi(s));
                    const g = Object.assign({
                            maxPadding: f,
                            w: o,
                            h: a,
                            x: n.left,
                            y: n.top
                        }, n),
                        p = Hi(l.concat(h), u);
                    qi(r.fullSize, g, u, p), qi(l, g, u, p), qi(h, g, u, p) && qi(l, g, u, p),
                        function (t) {
                            const e = t.maxPadding;

                            function i(i) {
                                const s = Math.max(e[i] - t[i], 0);
                                return t[i] += s, s
                            }
                            t.y += i("top"), t.x += i("left"), i("right"), i("bottom")
                        }(g), Gi(r.leftAndTop, g, u, p), g.x += g.w, g.y += g.h, Gi(r.rightAndBottom, g, u, p), t.chartArea = {
                            left: g.left,
                            top: g.top,
                            right: g.left + g.w,
                            bottom: g.top + g.h,
                            height: g.h,
                            width: g.w
                        }, d(r.chartArea, (e => {
                            const i = e.box;
                            Object.assign(i, t.chartArea), i.update(g.w, g.h, {
                                left: 0,
                                top: 0,
                                right: 0,
                                bottom: 0
                            })
                        }))
                }
            };
            class Ji {
                acquireContext(t, e) {}
                releaseContext(t) {
                    return !1
                }
                addEventListener(t, e, i) {}
                removeEventListener(t, e, i) {}
                getDevicePixelRatio() {
                    return 1
                }
                getMaximumSize(t, e, i, s) {
                    return e = Math.max(0, e || t.width), i = i || t.height, {
                        width: e,
                        height: Math.max(0, s ? Math.floor(e / s) : i)
                    }
                }
                isAttached(t) {
                    return !0
                }
                updateConfig(t) {}
            }
            class Qi extends Ji {
                acquireContext(t) {
                    return t && t.getContext && t.getContext("2d") || null
                }
                updateConfig(t) {
                    t.options.animation = !1
                }
            }
            const ts = {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup",
                    pointerenter: "mouseenter",
                    pointerdown: "mousedown",
                    pointermove: "mousemove",
                    pointerup: "mouseup",
                    pointerleave: "mouseout",
                    pointerout: "mouseout"
                },
                es = t => null === t || "" === t;
            const is = !!me && {
                passive: !0
            };

            function ss(t, e, i) {
                t.canvas.removeEventListener(e, i, is)
            }

            function ns(t, e) {
                for (const i of t)
                    if (i === e || i.contains(e)) return !0
            }

            function os(t, e, i) {
                const s = t.canvas,
                    n = new MutationObserver((t => {
                        let e = !1;
                        for (const i of t) e = e || ns(i.addedNodes, s), e = e && !ns(i.removedNodes, s);
                        e && i()
                    }));
                return n.observe(document, {
                    childList: !0,
                    subtree: !0
                }), n
            }

            function as(t, e, i) {
                const s = t.canvas,
                    n = new MutationObserver((t => {
                        let e = !1;
                        for (const i of t) e = e || ns(i.removedNodes, s), e = e && !ns(i.addedNodes, s);
                        e && i()
                    }));
                return n.observe(document, {
                    childList: !0,
                    subtree: !0
                }), n
            }
            const rs = new Map;
            let ls = 0;

            function hs() {
                const t = window.devicePixelRatio;
                t !== ls && (ls = t, rs.forEach(((e, i) => {
                    i.currentDevicePixelRatio !== t && e()
                })))
            }

            function cs(t, e, i) {
                const s = t.canvas,
                    n = s && ae(s);
                if (!n) return;
                const o = ht(((t, e) => {
                        const s = n.clientWidth;
                        i(t, e), s < n.clientWidth && i()
                    }), window),
                    a = new ResizeObserver((t => {
                        const e = t[0],
                            i = e.contentRect.width,
                            s = e.contentRect.height;
                        0 === i && 0 === s || o(i, s)
                    }));
                return a.observe(n),
                    function (t, e) {
                        rs.size || window.addEventListener("resize", hs), rs.set(t, e)
                    }(t, o), a
            }

            function ds(t, e, i) {
                i && i.disconnect(), "resize" === e && function (t) {
                    rs.delete(t), rs.size || window.removeEventListener("resize", hs)
                }(t)
            }

            function us(t, e, i) {
                const s = t.canvas,
                    n = ht((e => {
                        null !== t.ctx && i(function (t, e) {
                            const i = ts[t.type] || t.type,
                                {
                                    x: s,
                                    y: n
                                } = ue(t, e);
                            return {
                                type: i,
                                chart: e,
                                native: t,
                                x: void 0 !== s ? s : null,
                                y: void 0 !== n ? n : null
                            }
                        }(e, t))
                    }), t, (t => {
                        const e = t[0];
                        return [e, e.offsetX, e.offsetY]
                    }));
                return function (t, e, i) {
                    t.addEventListener(e, i, is)
                }(s, e, n), n
            }
            class fs extends Ji {
                acquireContext(t, e) {
                    const i = t && t.getContext && t.getContext("2d");
                    return i && i.canvas === t ? (function (t, e) {
                        const i = t.style,
                            s = t.getAttribute("height"),
                            n = t.getAttribute("width");
                        if (t.$chartjs = {
                                initial: {
                                    height: s,
                                    width: n,
                                    style: {
                                        display: i.display,
                                        height: i.height,
                                        width: i.width
                                    }
                                }
                            }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", es(n)) {
                            const e = be(t, "width");
                            void 0 !== e && (t.width = e)
                        }
                        if (es(s))
                            if ("" === t.style.height) t.height = t.width / (e || 2);
                            else {
                                const e = be(t, "height");
                                void 0 !== e && (t.height = e)
                            }
                    }(t, e), i) : null
                }
                releaseContext(t) {
                    const e = t.canvas;
                    if (!e.$chartjs) return !1;
                    const s = e.$chartjs.initial;
                    ["height", "width"].forEach((t => {
                        const n = s[t];
                        i(n) ? e.removeAttribute(t) : e.setAttribute(t, n)
                    }));
                    const n = s.style || {};
                    return Object.keys(n).forEach((t => {
                        e.style[t] = n[t]
                    })), e.width = e.width, delete e.$chartjs, !0
                }
                addEventListener(t, e, i) {
                    this.removeEventListener(t, e);
                    const s = t.$proxies || (t.$proxies = {}),
                        n = {
                            attach: os,
                            detach: as,
                            resize: cs
                        } [e] || us;
                    s[e] = n(t, e, i)
                }
                removeEventListener(t, e) {
                    const i = t.$proxies || (t.$proxies = {}),
                        s = i[e];
                    if (!s) return;
                    ({
                        attach: ds,
                        detach: ds,
                        resize: ds
                    } [e] || ss)(t, e, s), i[e] = void 0
                }
                getDevicePixelRatio() {
                    return window.devicePixelRatio
                }
                getMaximumSize(t, e, i, s) {
                    return ge(t, e, i, s)
                }
                isAttached(t) {
                    const e = ae(t);
                    return !(!e || !e.isConnected)
                }
            }

            function gs(t) {
                return !oe() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? Qi : fs
            }
            var ps = Object.freeze({
                __proto__: null,
                _detectPlatform: gs,
                BasePlatform: Ji,
                BasicPlatform: Qi,
                DomPlatform: fs
            });
            const ms = "transparent",
                bs = {
                    boolean: (t, e, i) => i > .5 ? e : t,
                    color(t, e, i) {
                        const s = Jt(t || ms),
                            n = s.valid && Jt(e || ms);
                        return n && n.valid ? n.mix(s, i).hexString() : e
                    },
                    number: (t, e, i) => t + (e - t) * i
                };
            class xs {
                constructor(t, e, i, s) {
                    const n = e[i];
                    s = bi([t.to, s, n, t.from]);
                    const o = bi([t.from, n, s]);
                    this._active = !0, this._fn = t.fn || bs[t.type || typeof o], this._easing = si[t.easing] || si.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0
                }
                active() {
                    return this._active
                }
                update(t, e, i) {
                    if (this._active) {
                        this._notify(!1);
                        const s = this._target[this._prop],
                            n = i - this._start,
                            o = this._duration - n;
                        this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = bi([t.to, e, s, t.from]), this._from = bi([t.from, s, e])
                    }
                }
                cancel() {
                    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
                }
                tick(t) {
                    const e = t - this._start,
                        i = this._duration,
                        s = this._prop,
                        n = this._from,
                        o = this._loop,
                        a = this._to;
                    let r;
                    if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);
                    e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r))
                }
                wait() {
                    const t = this._promises || (this._promises = []);
                    return new Promise(((e, i) => {
                        t.push({
                            res: e,
                            rej: i
                        })
                    }))
                }
                _notify(t) {
                    const e = t ? "res" : "rej",
                        i = this._promises || [];
                    for (let t = 0; t < i.length; t++) i[t][e]()
                }
            }
            ne.set("animation", {
                delay: void 0,
                duration: 1e3,
                easing: "easeOutQuart",
                fn: void 0,
                from: void 0,
                loop: void 0,
                to: void 0,
                type: void 0
            });
            const _s = Object.keys(ne.animation);
            ne.describe("animation", {
                _fallback: !1,
                _indexable: !1,
                _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
            }), ne.set("animations", {
                colors: {
                    type: "color",
                    properties: ["color", "borderColor", "backgroundColor"]
                },
                numbers: {
                    type: "number",
                    properties: ["x", "y", "borderWidth", "radius", "tension"]
                }
            }), ne.describe("animations", {
                _fallback: "animation"
            }), ne.set("transitions", {
                active: {
                    animation: {
                        duration: 400
                    }
                },
                resize: {
                    animation: {
                        duration: 0
                    }
                },
                show: {
                    animations: {
                        colors: {
                            from: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            duration: 0
                        }
                    }
                },
                hide: {
                    animations: {
                        colors: {
                            to: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            easing: "linear",
                            fn: t => 0 | t
                        }
                    }
                }
            });
            class ys {
                constructor(t, e) {
                    this._chart = t, this._properties = new Map, this.configure(e)
                }
                configure(t) {
                    if (!n(t)) return;
                    const e = this._properties;
                    Object.getOwnPropertyNames(t).forEach((i => {
                        const o = t[i];
                        if (!n(o)) return;
                        const a = {};
                        for (const t of _s) a[t] = o[t];
                        (s(o.properties) && o.properties || [i]).forEach((t => {
                            t !== i && e.has(t) || e.set(t, a)
                        }))
                    }))
                }
                _animateOptions(t, e) {
                    const i = e.options,
                        s = function (t, e) {
                            if (!e) return;
                            let i = t.options;
                            if (!i) return void(t.options = e);
                            i.$shared && (t.options = i = Object.assign({}, i, {
                                $shared: !1,
                                $animations: {}
                            }));
                            return i
                        }(t, i);
                    if (!s) return [];
                    const n = this._createAnimations(s, i);
                    return i.$shared && function (t, e) {
                        const i = [],
                            s = Object.keys(e);
                        for (let e = 0; e < s.length; e++) {
                            const n = t[s[e]];
                            n && n.active() && i.push(n.wait())
                        }
                        return Promise.all(i)
                    }(t.options.$animations, i).then((() => {
                        t.options = i
                    }), (() => {})), n
                }
                _createAnimations(t, e) {
                    const i = this._properties,
                        s = [],
                        n = t.$animations || (t.$animations = {}),
                        o = Object.keys(e),
                        a = Date.now();
                    let r;
                    for (r = o.length - 1; r >= 0; --r) {
                        const l = o[r];
                        if ("$" === l.charAt(0)) continue;
                        if ("options" === l) {
                            s.push(...this._animateOptions(t, e));
                            continue
                        }
                        const h = e[l];
                        let c = n[l];
                        const d = i.get(l);
                        if (c) {
                            if (d && c.active()) {
                                c.update(d, h, a);
                                continue
                            }
                            c.cancel()
                        }
                        d && d.duration ? (n[l] = c = new xs(d, t, l, h), s.push(c)) : t[l] = h
                    }
                    return s
                }
                update(t, e) {
                    if (0 === this._properties.size) return void Object.assign(t, e);
                    const i = this._createAnimations(t, e);
                    return i.length ? (mt.add(this._chart, i), !0) : void 0
                }
            }

            function vs(t, e) {
                const i = t && t.options || {},
                    s = i.reverse,
                    n = void 0 === i.min ? e : 0,
                    o = void 0 === i.max ? e : 0;
                return {
                    start: s ? o : n,
                    end: s ? n : o
                }
            }

            function ws(t, e) {
                const i = [],
                    s = t._getSortedDatasetMetas(e);
                let n, o;
                for (n = 0, o = s.length; n < o; ++n) i.push(s[n].index);
                return i
            }

            function Ms(t, e, i, s = {}) {
                const n = t.keys,
                    a = "single" === s.mode;
                let r, l, h, c;
                if (null !== e) {
                    for (r = 0, l = n.length; r < l; ++r) {
                        if (h = +n[r], h === i) {
                            if (s.all) continue;
                            break
                        }
                        c = t.values[h], o(c) && (a || 0 === e || z(e) === z(c)) && (e += c)
                    }
                    return e
                }
            }

            function ks(t, e) {
                const i = t && t.options.stacked;
                return i || void 0 === i && void 0 !== e.stack
            }

            function Ss(t, e, i) {
                const s = t[e] || (t[e] = {});
                return s[i] || (s[i] = {})
            }

            function Ps(t, e, i, s) {
                for (const n of e.getMatchingVisibleMetas(s).reverse()) {
                    const e = t[n.index];
                    if (i && e > 0 || !i && e < 0) return n.index
                }
                return null
            }

            function Ds(t, e) {
                const {
                    chart: i,
                    _cachedMeta: s
                } = t, n = i._stacks || (i._stacks = {}), {
                    iScale: o,
                    vScale: a,
                    index: r
                } = s, l = o.axis, h = a.axis, c = function (t, e, i) {
                    return `${t.id}.${e.id}.${i.stack||i.type}`
                }(o, a, s), d = e.length;
                let u;
                for (let t = 0; t < d; ++t) {
                    const i = e[t],
                        {
                            [l]: o,
                            [h]: d
                        } = i;
                    u = (i._stacks || (i._stacks = {}))[h] = Ss(n, c, o), u[r] = d, u._top = Ps(u, a, !0, s.type), u._bottom = Ps(u, a, !1, s.type)
                }
            }

            function Os(t, e) {
                const i = t.scales;
                return Object.keys(i).filter((t => i[t].axis === e)).shift()
            }

            function Cs(t, e) {
                const i = t.controller.index,
                    s = t.vScale && t.vScale.axis;
                if (s) {
                    e = e || t._parsed;
                    for (const t of e) {
                        const e = t._stacks;
                        if (!e || void 0 === e[s] || void 0 === e[s][i]) return;
                        delete e[s][i]
                    }
                }
            }
            const As = t => "reset" === t || "none" === t,
                Ts = (t, e) => e ? t : Object.assign({}, t);
            class Ls {
                constructor(t, e) {
                    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize()
                }
                initialize() {
                    const t = this._cachedMeta;
                    this.configure(), this.linkScales(), t._stacked = ks(t.vScale, t), this.addElements()
                }
                updateIndex(t) {
                    this.index !== t && Cs(this._cachedMeta), this.index = t
                }
                linkScales() {
                    const t = this.chart,
                        e = this._cachedMeta,
                        i = this.getDataset(),
                        s = (t, e, i, s) => "x" === t ? e : "r" === t ? s : i,
                        n = e.xAxisID = r(i.xAxisID, Os(t, "x")),
                        o = e.yAxisID = r(i.yAxisID, Os(t, "y")),
                        a = e.rAxisID = r(i.rAxisID, Os(t, "r")),
                        l = e.indexAxis,
                        h = e.iAxisID = s(l, n, o, a),
                        c = e.vAxisID = s(l, o, n, a);
                    e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c)
                }
                getDataset() {
                    return this.chart.data.datasets[this.index]
                }
                getMeta() {
                    return this.chart.getDatasetMeta(this.index)
                }
                getScaleForId(t) {
                    return this.chart.scales[t]
                }
                _getOtherScale(t) {
                    const e = this._cachedMeta;
                    return t === e.iScale ? e.vScale : e.iScale
                }
                reset() {
                    this._update("reset")
                }
                _destroy() {
                    const t = this._cachedMeta;
                    this._data && at(this._data, this), t._stacked && Cs(t)
                }
                _dataCheck() {
                    const t = this.getDataset(),
                        e = t.data || (t.data = []),
                        i = this._data;
                    if (n(e)) this._data = function (t) {
                        const e = Object.keys(t),
                            i = new Array(e.length);
                        let s, n, o;
                        for (s = 0, n = e.length; s < n; ++s) o = e[s], i[s] = {
                            x: o,
                            y: t[o]
                        };
                        return i
                    }(e);
                    else if (i !== e) {
                        if (i) {
                            at(i, this);
                            const t = this._cachedMeta;
                            Cs(t), t._parsed = []
                        }
                        e && Object.isExtensible(e) && ot(e, this), this._syncList = [], this._data = e
                    }
                }
                addElements() {
                    const t = this._cachedMeta;
                    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
                }
                buildOrUpdateElements(t) {
                    const e = this._cachedMeta,
                        i = this.getDataset();
                    let s = !1;
                    this._dataCheck();
                    const n = e._stacked;
                    e._stacked = ks(e.vScale, e), e.stack !== i.stack && (s = !0, Cs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && Ds(this, e._parsed)
                }
                configure() {
                    const t = this.chart.config,
                        e = t.datasetScopeKeys(this._type),
                        i = t.getOptionScopes(this.getDataset(), e, !0);
                    this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {}
                }
                parse(t, e) {
                    const {
                        _cachedMeta: i,
                        _data: o
                    } = this, {
                        iScale: a,
                        _stacked: r
                    } = i, l = a.axis;
                    let h, c, d, u = 0 === t && e === o.length || i._sorted,
                        f = t > 0 && i._parsed[t - 1];
                    if (!1 === this._parsing) i._parsed = o, i._sorted = !0, d = o;
                    else {
                        d = s(o[t]) ? this.parseArrayData(i, o, t, e) : n(o[t]) ? this.parseObjectData(i, o, t, e) : this.parsePrimitiveData(i, o, t, e);
                        const a = () => null === c[l] || f && c[l] < f[l];
                        for (h = 0; h < e; ++h) i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);
                        i._sorted = u
                    }
                    r && Ds(this, d)
                }
                parsePrimitiveData(t, e, i, s) {
                    const {
                        iScale: n,
                        vScale: o
                    } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);
                    let d, u, f;
                    for (d = 0, u = s; d < u; ++d) f = d + i, c[d] = {
                        [a]: h || n.parse(l[f], f),
                        [r]: o.parse(e[f], f)
                    };
                    return c
                }
                parseArrayData(t, e, i, s) {
                    const {
                        xScale: n,
                        yScale: o
                    } = t, a = new Array(s);
                    let r, l, h, c;
                    for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {
                        x: n.parse(c[0], h),
                        y: o.parse(c[1], h)
                    };
                    return a
                }
                parseObjectData(t, e, i, s) {
                    const {
                        xScale: n,
                        yScale: o
                    } = t, {
                        xAxisKey: a = "x",
                        yAxisKey: r = "y"
                    } = this._parsing, l = new Array(s);
                    let h, c, d, u;
                    for (h = 0, c = s; h < c; ++h) d = h + i, u = e[d], l[h] = {
                        x: n.parse(y(u, a), d),
                        y: o.parse(y(u, r), d)
                    };
                    return l
                }
                getParsed(t) {
                    return this._cachedMeta._parsed[t]
                }
                getDataElement(t) {
                    return this._cachedMeta.data[t]
                }
                applyStack(t, e, i) {
                    const s = this.chart,
                        n = this._cachedMeta,
                        o = e[t.axis];
                    return Ms({
                        keys: ws(s, !0),
                        values: e._stacks[t.axis]
                    }, o, n.index, {
                        mode: i
                    })
                }
                updateRangeFromParsed(t, e, i, s) {
                    const n = i[e.axis];
                    let o = null === n ? NaN : n;
                    const a = s && i._stacks[e.axis];
                    s && a && (s.values = a, o = Ms(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)
                }
                getMinMax(t, e) {
                    const i = this._cachedMeta,
                        s = i._parsed,
                        n = i._sorted && t === i.iScale,
                        a = s.length,
                        r = this._getOtherScale(t),
                        l = ((t, e, i) => t && !e.hidden && e._stacked && {
                            keys: ws(i, !0),
                            values: null
                        })(e, i, this.chart),
                        h = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        },
                        {
                            min: c,
                            max: d
                        } = function (t) {
                            const {
                                min: e,
                                max: i,
                                minDefined: s,
                                maxDefined: n
                            } = t.getUserBounds();
                            return {
                                min: s ? e : Number.NEGATIVE_INFINITY,
                                max: n ? i : Number.POSITIVE_INFINITY
                            }
                        }(r);
                    let u, f;

                    function g() {
                        f = s[u];
                        const e = f[r.axis];
                        return !o(f[t.axis]) || c > e || d < e
                    }
                    for (u = 0; u < a && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);
                    if (n)
                        for (u = a - 1; u >= 0; --u)
                            if (!g()) {
                                this.updateRangeFromParsed(h, t, f, l);
                                break
                            } return h
                }
                getAllParsedValues(t) {
                    const e = this._cachedMeta._parsed,
                        i = [];
                    let s, n, a;
                    for (s = 0, n = e.length; s < n; ++s) a = e[s][t.axis], o(a) && i.push(a);
                    return i
                }
                getMaxOverflow() {
                    return !1
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = e.iScale,
                        s = e.vScale,
                        n = this.getParsed(t);
                    return {
                        label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
                        value: s ? "" + s.getLabelForValue(n[s.axis]) : ""
                    }
                }
                _update(t) {
                    const e = this._cachedMeta;
                    this.update(t || "default"), e._clip = function (t) {
                        let e, i, s, o;
                        return n(t) ? (e = t.top, i = t.right, s = t.bottom, o = t.left) : e = i = s = o = t, {
                            top: e,
                            right: i,
                            bottom: s,
                            left: o,
                            disabled: !1 === t
                        }
                    }(r(this.options.clip, function (t, e, i) {
                        if (!1 === i) return !1;
                        const s = vs(t, i),
                            n = vs(e, i);
                        return {
                            top: n.end,
                            right: s.end,
                            bottom: n.start,
                            left: s.start
                        }
                    }(e.xScale, e.yScale, this.getMaxOverflow())))
                }
                update(t) {}
                draw() {
                    const t = this._ctx,
                        e = this.chart,
                        i = this._cachedMeta,
                        s = i.data || [],
                        n = e.chartArea,
                        o = [],
                        a = this._drawStart || 0,
                        r = this._drawCount || s.length - a,
                        l = this.options.drawActiveElementsOnTop;
                    let h;
                    for (i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h) {
                        const e = s[h];
                        e.hidden || (e.active && l ? o.push(e) : e.draw(t, n))
                    }
                    for (h = 0; h < o.length; ++h) o[h].draw(t, n)
                }
                getStyle(t, e) {
                    const i = e ? "active" : "default";
                    return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i)
                }
                getContext(t, e, i) {
                    const s = this.getDataset();
                    let n;
                    if (t >= 0 && t < this._cachedMeta.data.length) {
                        const e = this._cachedMeta.data[t];
                        n = e.$context || (e.$context = function (t, e, i) {
                            return _i(t, {
                                active: !1,
                                dataIndex: e,
                                parsed: void 0,
                                raw: void 0,
                                element: i,
                                index: e,
                                mode: "default",
                                type: "data"
                            })
                        }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t
                    } else n = this.$context || (this.$context = function (t, e) {
                        return _i(t, {
                            active: !1,
                            dataset: void 0,
                            datasetIndex: e,
                            index: e,
                            mode: "default",
                            type: "dataset"
                        })
                    }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;
                    return n.active = !!e, n.mode = i, n
                }
                resolveDatasetElementOptions(t) {
                    return this._resolveElementOptions(this.datasetElementType.id, t)
                }
                resolveDataElementOptions(t, e) {
                    return this._resolveElementOptions(this.dataElementType.id, e, t)
                }
                _resolveElementOptions(t, e = "default", i) {
                    const s = "active" === e,
                        n = this._cachedDataOpts,
                        o = t + "-" + e,
                        a = n[o],
                        r = this.enableOptionSharing && M(i);
                    if (a) return Ts(a, r);
                    const l = this.chart.config,
                        h = l.datasetElementScopeKeys(this._type, t),
                        c = s ? [`${t}Hover`, "hover", t, ""] : [t, ""],
                        d = l.getOptionScopes(this.getDataset(), h),
                        u = Object.keys(ne.elements[t]),
                        f = l.resolveNamedOptions(d, u, (() => this.getContext(i, s)), c);
                    return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ts(f, r))), f
                }
                _resolveAnimations(t, e, i) {
                    const s = this.chart,
                        n = this._cachedDataOpts,
                        o = `animation-${e}`,
                        a = n[o];
                    if (a) return a;
                    let r;
                    if (!1 !== s.options.animation) {
                        const s = this.chart.config,
                            n = s.datasetAnimationScopeKeys(this._type, e),
                            o = s.getOptionScopes(this.getDataset(), n);
                        r = s.createResolver(o, this.getContext(t, i, e))
                    }
                    const l = new ys(s, r && r.animations);
                    return r && r._cacheable && (n[o] = Object.freeze(l)), l
                }
                getSharedOptions(t) {
                    if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
                }
                includeOptions(t, e) {
                    return !e || As(t) || this.chart._animationsDisabled
                }
                _getSharedOptions(t, e) {
                    const i = this.resolveDataElementOptions(t, e),
                        s = this._sharedOptions,
                        n = this.getSharedOptions(i),
                        o = this.includeOptions(e, n) || n !== s;
                    return this.updateSharedOptions(n, e, i), {
                        sharedOptions: n,
                        includeOptions: o
                    }
                }
                updateElement(t, e, i, s) {
                    As(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i)
                }
                updateSharedOptions(t, e, i) {
                    t && !As(e) && this._resolveAnimations(void 0, e).update(t, i)
                }
                _setStyle(t, e, i, s) {
                    t.active = s;
                    const n = this.getStyle(e, s);
                    this._resolveAnimations(e, i, s).update(t, {
                        options: !s && this.getSharedOptions(n) || n
                    })
                }
                removeHoverStyle(t, e, i) {
                    this._setStyle(t, i, "active", !1)
                }
                setHoverStyle(t, e, i) {
                    this._setStyle(t, i, "active", !0)
                }
                _removeDatasetHoverStyle() {
                    const t = this._cachedMeta.dataset;
                    t && this._setStyle(t, void 0, "active", !1)
                }
                _setDatasetHoverStyle() {
                    const t = this._cachedMeta.dataset;
                    t && this._setStyle(t, void 0, "active", !0)
                }
                _resyncElements(t) {
                    const e = this._data,
                        i = this._cachedMeta.data;
                    for (const [t, e, i] of this._syncList) this[t](e, i);
                    this._syncList = [];
                    const s = i.length,
                        n = e.length,
                        o = Math.min(n, s);
                    o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n)
                }
                _insertElements(t, e, i = !0) {
                    const s = this._cachedMeta,
                        n = s.data,
                        o = t + e;
                    let a;
                    const r = t => {
                        for (t.length += e, a = t.length - 1; a >= o; a--) t[a] = t[a - e]
                    };
                    for (r(n), a = t; a < o; ++a) n[a] = new this.dataElementType;
                    this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, "reset")
                }
                updateElements(t, e, i, s) {}
                _removeElements(t, e) {
                    const i = this._cachedMeta;
                    if (this._parsing) {
                        const s = i._parsed.splice(t, e);
                        i._stacked && Cs(i, s)
                    }
                    i.data.splice(t, e)
                }
                _sync(t) {
                    if (this._parsing) this._syncList.push(t);
                    else {
                        const [e, i, s] = t;
                        this[e](i, s)
                    }
                    this.chart._dataChanges.push([this.index, ...t])
                }
                _onDataPush() {
                    const t = arguments.length;
                    this._sync(["_insertElements", this.getDataset().data.length - t, t])
                }
                _onDataPop() {
                    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
                }
                _onDataShift() {
                    this._sync(["_removeElements", 0, 1])
                }
                _onDataSplice(t, e) {
                    e && this._sync(["_removeElements", t, e]);
                    const i = arguments.length - 2;
                    i && this._sync(["_insertElements", t, i])
                }
                _onDataUnshift() {
                    this._sync(["_insertElements", 0, arguments.length])
                }
            }
            Ls.defaults = {}, Ls.prototype.datasetElementType = null, Ls.prototype.dataElementType = null;
            class Es {
                constructor() {
                    this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0
                }
                tooltipPosition(t) {
                    const {
                        x: e,
                        y: i
                    } = this.getProps(["x", "y"], t);
                    return {
                        x: e,
                        y: i
                    }
                }
                hasValue() {
                    return B(this.x) && B(this.y)
                }
                getProps(t, e) {
                    const i = this.$animations;
                    if (!e || !i) return this;
                    const s = {};
                    return t.forEach((t => {
                        s[t] = i[t] && i[t].active() ? i[t]._to : this[t]
                    })), s
                }
            }
            Es.defaults = {}, Es.defaultRoutes = void 0;
            const Rs = {
                values: t => s(t) ? t : "" + t,
                numeric(t, e, i) {
                    if (0 === t) return "0";
                    const s = this.chart.options.locale;
                    let n, o = t;
                    if (i.length > 1) {
                        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
                        (e < 1e-4 || e > 1e15) && (n = "scientific"), o = function (t, e) {
                            let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
                            Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));
                            return i
                        }(t, i)
                    }
                    const a = I(Math.abs(o)),
                        r = Math.max(Math.min(-1 * Math.floor(a), 20), 0),
                        l = {
                            notation: n,
                            minimumFractionDigits: r,
                            maximumFractionDigits: r
                        };
                    return Object.assign(l, this.options.ticks.format), li(t, s, l)
                },
                logarithmic(t, e, i) {
                    if (0 === t) return "0";
                    const s = t / Math.pow(10, Math.floor(I(t)));
                    return 1 === s || 2 === s || 5 === s ? Rs.numeric.call(this, t, e, i) : ""
                }
            };
            var Is = {
                formatters: Rs
            };

            function zs(t, e) {
                const s = t.options.ticks,
                    n = s.maxTicksLimit || function (t) {
                        const e = t.options.offset,
                            i = t._tickSize(),
                            s = t._length / i + (e ? 0 : 1),
                            n = t._maxLength / i;
                        return Math.floor(Math.min(s, n))
                    }(t),
                    o = s.major.enabled ? function (t) {
                        const e = [];
                        let i, s;
                        for (i = 0, s = t.length; i < s; i++) t[i].major && e.push(i);
                        return e
                    }(e) : [],
                    a = o.length,
                    r = o[0],
                    l = o[a - 1],
                    h = [];
                if (a > n) return function (t, e, i, s) {
                    let n, o = 0,
                        a = i[0];
                    for (s = Math.ceil(s), n = 0; n < t.length; n++) n === a && (e.push(t[n]), o++, a = i[o * s])
                }(e, h, o, a / n), h;
                const c = function (t, e, i) {
                    const s = function (t) {
                            const e = t.length;
                            let i, s;
                            if (e < 2) return !1;
                            for (s = t[0], i = 1; i < e; ++i)
                                if (t[i] - t[i - 1] !== s) return !1;
                            return s
                        }(t),
                        n = e.length / i;
                    if (!s) return Math.max(n, 1);
                    const o = V(s);
                    for (let t = 0, e = o.length - 1; t < e; t++) {
                        const e = o[t];
                        if (e > n) return e
                    }
                    return Math.max(n, 1)
                }(o, e, n);
                if (a > 0) {
                    let t, s;
                    const n = a > 1 ? Math.round((l - r) / (a - 1)) : null;
                    for (Fs(e, h, c, i(n) ? 0 : r - n, r), t = 0, s = a - 1; t < s; t++) Fs(e, h, c, o[t], o[t + 1]);
                    return Fs(e, h, c, l, i(n) ? e.length : l + n), h
                }
                return Fs(e, h, c), h
            }

            function Fs(t, e, i, s, n) {
                const o = r(s, 0),
                    a = Math.min(r(n, t.length), t.length);
                let l, h, c, d = 0;
                for (i = Math.ceil(i), n && (l = n - s, i = l / Math.floor(l / i)), c = o; c < 0;) d++, c = Math.round(o + d * i);
                for (h = Math.max(o, 0); h < a; h++) h === c && (e.push(t[h]), d++, c = Math.round(o + d * i))
            }
            ne.set("scale", {
                display: !0,
                offset: !1,
                reverse: !1,
                beginAtZero: !1,
                bounds: "ticks",
                grace: 0,
                grid: {
                    display: !0,
                    lineWidth: 1,
                    drawBorder: !0,
                    drawOnChartArea: !0,
                    drawTicks: !0,
                    tickLength: 8,
                    tickWidth: (t, e) => e.lineWidth,
                    tickColor: (t, e) => e.color,
                    offset: !1,
                    borderDash: [],
                    borderDashOffset: 0,
                    borderWidth: 1
                },
                title: {
                    display: !1,
                    text: "",
                    padding: {
                        top: 4,
                        bottom: 4
                    }
                },
                ticks: {
                    minRotation: 0,
                    maxRotation: 50,
                    mirror: !1,
                    textStrokeWidth: 0,
                    textStrokeColor: "",
                    padding: 3,
                    display: !0,
                    autoSkip: !0,
                    autoSkipPadding: 3,
                    labelOffset: 0,
                    callback: Is.formatters.values,
                    minor: {},
                    major: {},
                    align: "center",
                    crossAlign: "near",
                    showLabelBackdrop: !1,
                    backdropColor: "rgba(255, 255, 255, 0.75)",
                    backdropPadding: 2
                }
            }), ne.route("scale.ticks", "color", "", "color"), ne.route("scale.grid", "color", "", "borderColor"), ne.route("scale.grid", "borderColor", "", "borderColor"), ne.route("scale.title", "color", "", "color"), ne.describe("scale", {
                _fallback: !1,
                _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
                _indexable: t => "borderDash" !== t && "tickBorderDash" !== t
            }), ne.describe("scales", {
                _fallback: "scale"
            }), ne.describe("scale.ticks", {
                _scriptable: t => "backdropPadding" !== t && "callback" !== t,
                _indexable: t => "backdropPadding" !== t
            });
            const Vs = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i;

            function Bs(t, e) {
                const i = [],
                    s = t.length / e,
                    n = t.length;
                let o = 0;
                for (; o < n; o += s) i.push(t[Math.floor(o)]);
                return i
            }

            function Ns(t, e, i) {
                const s = t.ticks.length,
                    n = Math.min(e, s - 1),
                    o = t._startPixel,
                    a = t._endPixel,
                    r = 1e-6;
                let l, h = t.getPixelForTick(n);
                if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h
            }

            function Ws(t) {
                return t.drawTicks ? t.tickLength : 0
            }

            function js(t, e) {
                if (!t.display) return 0;
                const i = mi(t.font, e),
                    n = pi(t.padding);
                return (s(t.text) ? t.text.length : 1) * i.lineHeight + n.height
            }

            function Hs(t, e, i) {
                let s = dt(t);
                return (i && "right" !== e || !i && "right" === e) && (s = (t => "left" === t ? "right" : "right" === t ? "left" : t)(s)), s
            }
            class $s extends Es {
                constructor(t) {
                    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
                }
                init(t) {
                    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax)
                }
                parse(t, e) {
                    return t
                }
                getUserBounds() {
                    let {
                        _userMin: t,
                        _userMax: e,
                        _suggestedMin: i,
                        _suggestedMax: s
                    } = this;
                    return t = a(t, Number.POSITIVE_INFINITY), e = a(e, Number.NEGATIVE_INFINITY), i = a(i, Number.POSITIVE_INFINITY), s = a(s, Number.NEGATIVE_INFINITY), {
                        min: a(t, i),
                        max: a(e, s),
                        minDefined: o(t),
                        maxDefined: o(e)
                    }
                }
                getMinMax(t) {
                    let e, {
                        min: i,
                        max: s,
                        minDefined: n,
                        maxDefined: o
                    } = this.getUserBounds();
                    if (n && o) return {
                        min: i,
                        max: s
                    };
                    const r = this.getMatchingVisibleMetas();
                    for (let a = 0, l = r.length; a < l; ++a) e = r[a].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));
                    return i = o && i > s ? s : i, s = n && i > s ? i : s, {
                        min: a(i, a(s, i)),
                        max: a(s, a(i, s))
                    }
                }
                getPadding() {
                    return {
                        left: this.paddingLeft || 0,
                        top: this.paddingTop || 0,
                        right: this.paddingRight || 0,
                        bottom: this.paddingBottom || 0
                    }
                }
                getTicks() {
                    return this.ticks
                }
                getLabels() {
                    const t = this.chart.data;
                    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
                }
                beforeLayout() {
                    this._cache = {}, this._dataLimitsCached = !1
                }
                beforeUpdate() {
                    c(this.options.beforeUpdate, [this])
                }
                update(t, e, i) {
                    const {
                        beginAtZero: s,
                        grace: n,
                        ticks: o
                    } = this.options, a = o.sampleSize;
                    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = xi(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
                    const r = a < this.ticks.length;
                    this._convertTicksToLabels(r ? Bs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = zs(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate()
                }
                configure() {
                    let t, e, i = this.options.reverse;
                    this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels
                }
                afterUpdate() {
                    c(this.options.afterUpdate, [this])
                }
                beforeSetDimensions() {
                    c(this.options.beforeSetDimensions, [this])
                }
                setDimensions() {
                    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0
                }
                afterSetDimensions() {
                    c(this.options.afterSetDimensions, [this])
                }
                _callHooks(t) {
                    this.chart.notifyPlugins(t, this.getContext()), c(this.options[t], [this])
                }
                beforeDataLimits() {
                    this._callHooks("beforeDataLimits")
                }
                determineDataLimits() {}
                afterDataLimits() {
                    this._callHooks("afterDataLimits")
                }
                beforeBuildTicks() {
                    this._callHooks("beforeBuildTicks")
                }
                buildTicks() {
                    return []
                }
                afterBuildTicks() {
                    this._callHooks("afterBuildTicks")
                }
                beforeTickToLabelConversion() {
                    c(this.options.beforeTickToLabelConversion, [this])
                }
                generateTickLabels(t) {
                    const e = this.options.ticks;
                    let i, s, n;
                    for (i = 0, s = t.length; i < s; i++) n = t[i], n.label = c(e.callback, [n.value, i, t], this)
                }
                afterTickToLabelConversion() {
                    c(this.options.afterTickToLabelConversion, [this])
                }
                beforeCalculateLabelRotation() {
                    c(this.options.beforeCalculateLabelRotation, [this])
                }
                calculateLabelRotation() {
                    const t = this.options,
                        e = t.ticks,
                        i = this.ticks.length,
                        s = e.minRotation || 0,
                        n = e.maxRotation;
                    let o, a, r, l = s;
                    if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void(this.labelRotation = s);
                    const h = this._getLabelSizes(),
                        c = h.widest.width,
                        d = h.highest.height,
                        u = Z(this.chart.width - c, 0, this.maxWidth);
                    o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ws(t.grid) - e.padding - js(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = $(Math.min(Math.asin(Z((h.highest.height + 6) / o, -1, 1)), Math.asin(Z(a / r, -1, 1)) - Math.asin(Z(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l
                }
                afterCalculateLabelRotation() {
                    c(this.options.afterCalculateLabelRotation, [this])
                }
                afterAutoSkip() {}
                beforeFit() {
                    c(this.options.beforeFit, [this])
                }
                fit() {
                    const t = {
                            width: 0,
                            height: 0
                        },
                        {
                            chart: e,
                            options: {
                                ticks: i,
                                title: s,
                                grid: n
                            }
                        } = this,
                        o = this._isVisible(),
                        a = this.isHorizontal();
                    if (o) {
                        const o = js(s, e.options.font);
                        if (a ? (t.width = this.maxWidth, t.height = Ws(n) + o) : (t.height = this.maxHeight, t.width = Ws(n) + o), i.display && this.ticks.length) {
                            const {
                                first: e,
                                last: s,
                                widest: n,
                                highest: o
                            } = this._getLabelSizes(), r = 2 * i.padding, l = H(this.labelRotation), h = Math.cos(l), c = Math.sin(l);
                            if (a) {
                                const e = i.mirror ? 0 : c * n.width + h * o.height;
                                t.height = Math.min(this.maxHeight, t.height + e + r)
                            } else {
                                const e = i.mirror ? 0 : h * n.width + c * o.height;
                                t.width = Math.min(this.maxWidth, t.width + e + r)
                            }
                            this._calculatePadding(e, s, c, h)
                        }
                    }
                    this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom)
                }
                _calculatePadding(t, e, i, s) {
                    const {
                        ticks: {
                            align: n,
                            padding: o
                        },
                        position: a
                    } = this.options, r = 0 !== this.labelRotation, l = "top" !== a && "x" === this.axis;
                    if (this.isHorizontal()) {
                        const a = this.getPixelForTick(0) - this.left,
                            h = this.right - this.getPixelForTick(this.ticks.length - 1);
                        let c = 0,
                            d = 0;
                        r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : "start" === n ? d = e.width : "end" === n ? c = t.width : "inner" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0)
                    } else {
                        let i = e.height / 2,
                            s = t.height / 2;
                        "start" === n ? (i = 0, s = t.height) : "end" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o
                    }
                }
                _handleMargins() {
                    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
                }
                afterFit() {
                    c(this.options.afterFit, [this])
                }
                isHorizontal() {
                    const {
                        axis: t,
                        position: e
                    } = this.options;
                    return "top" === e || "bottom" === e || "x" === t
                }
                isFullSize() {
                    return this.options.fullSize
                }
                _convertTicksToLabels(t) {
                    let e, s;
                    for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, s = t.length; e < s; e++) i(t[e].label) && (t.splice(e, 1), s--, e--);
                    this.afterTickToLabelConversion()
                }
                _getLabelSizes() {
                    let t = this._labelSizes;
                    if (!t) {
                        const e = this.options.ticks.sampleSize;
                        let i = this.ticks;
                        e < i.length && (i = Bs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length)
                    }
                    return t
                }
                _computeLabelSizes(t, e) {
                    const {
                        ctx: n,
                        _longestTextCache: o
                    } = this, a = [], r = [];
                    let l, h, c, u, f, g, p, m, b, x, _, y = 0,
                        v = 0;
                    for (l = 0; l < e; ++l) {
                        if (u = t[l].label, f = this._resolveTickFontOptions(l), n.font = g = f.string, p = o[g] = o[g] || {
                                data: {},
                                gc: []
                            }, m = f.lineHeight, b = x = 0, i(u) || s(u)) {
                            if (s(u))
                                for (h = 0, c = u.length; h < c; ++h) _ = u[h], i(_) || s(_) || (b = _e(n, p.data, p.gc, b, _), x += m)
                        } else b = _e(n, p.data, p.gc, b, u), x = m;
                        a.push(b), r.push(x), y = Math.max(b, y), v = Math.max(x, v)
                    }! function (t, e) {
                        d(t, (t => {
                            const i = t.gc,
                                s = i.length / 2;
                            let n;
                            if (s > e) {
                                for (n = 0; n < s; ++n) delete t.data[i[n]];
                                i.splice(0, s)
                            }
                        }))
                    }(o, e);
                    const w = a.indexOf(y),
                        M = r.indexOf(v),
                        k = t => ({
                            width: a[t] || 0,
                            height: r[t] || 0
                        });
                    return {
                        first: k(0),
                        last: k(e - 1),
                        widest: k(w),
                        highest: k(M),
                        widths: a,
                        heights: r
                    }
                }
                getLabelForValue(t) {
                    return t
                }
                getPixelForValue(t, e) {
                    return NaN
                }
                getValueForPixel(t) {}
                getPixelForTick(t) {
                    const e = this.ticks;
                    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
                }
                getPixelForDecimal(t) {
                    this._reversePixels && (t = 1 - t);
                    const e = this._startPixel + t * this._length;
                    return J(this._alignToPixels ? ve(this.chart, e, 0) : e)
                }
                getDecimalForPixel(t) {
                    const e = (t - this._startPixel) / this._length;
                    return this._reversePixels ? 1 - e : e
                }
                getBasePixel() {
                    return this.getPixelForValue(this.getBaseValue())
                }
                getBaseValue() {
                    const {
                        min: t,
                        max: e
                    } = this;
                    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
                }
                getContext(t) {
                    const e = this.ticks || [];
                    if (t >= 0 && t < e.length) {
                        const i = e[t];
                        return i.$context || (i.$context = function (t, e, i) {
                            return _i(t, {
                                tick: i,
                                index: e,
                                type: "tick"
                            })
                        }(this.getContext(), t, i))
                    }
                    return this.$context || (this.$context = _i(this.chart.getContext(), {
                        scale: this,
                        type: "scale"
                    }))
                }
                _tickSize() {
                    const t = this.options.ticks,
                        e = H(this.labelRotation),
                        i = Math.abs(Math.cos(e)),
                        s = Math.abs(Math.sin(e)),
                        n = this._getLabelSizes(),
                        o = t.autoSkipPadding || 0,
                        a = n ? n.widest.width + o : 0,
                        r = n ? n.highest.height + o : 0;
                    return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s
                }
                _isVisible() {
                    const t = this.options.display;
                    return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0
                }
                _computeGridLineItems(t) {
                    const e = this.axis,
                        i = this.chart,
                        s = this.options,
                        {
                            grid: o,
                            position: a
                        } = s,
                        l = o.offset,
                        h = this.isHorizontal(),
                        c = this.ticks.length + (l ? 1 : 0),
                        d = Ws(o),
                        u = [],
                        f = o.setContext(this.getContext()),
                        g = f.drawBorder ? f.borderWidth : 0,
                        p = g / 2,
                        m = function (t) {
                            return ve(i, t, g)
                        };
                    let b, x, _, y, v, w, M, k, S, P, D, O;
                    if ("top" === a) b = m(this.bottom), w = this.bottom - d, k = b - p, P = m(t.top) + p, O = t.bottom;
                    else if ("bottom" === a) b = m(this.top), P = t.top, O = m(t.bottom) - p, w = b + p, k = this.top + d;
                    else if ("left" === a) b = m(this.right), v = this.right - d, M = b - p, S = m(t.left) + p, D = t.right;
                    else if ("right" === a) b = m(this.left), S = t.left, D = m(t.right) - p, v = b + p, M = this.left + d;
                    else if ("x" === e) {
                        if ("center" === a) b = m((t.top + t.bottom) / 2 + .5);
                        else if (n(a)) {
                            const t = Object.keys(a)[0],
                                e = a[t];
                            b = m(this.chart.scales[t].getPixelForValue(e))
                        }
                        P = t.top, O = t.bottom, w = b + p, k = w + d
                    } else if ("y" === e) {
                        if ("center" === a) b = m((t.left + t.right) / 2);
                        else if (n(a)) {
                            const t = Object.keys(a)[0],
                                e = a[t];
                            b = m(this.chart.scales[t].getPixelForValue(e))
                        }
                        v = b - p, M = v - d, S = t.left, D = t.right
                    }
                    const C = r(s.ticks.maxTicksLimit, c),
                        A = Math.max(1, Math.ceil(c / C));
                    for (x = 0; x < c; x += A) {
                        const t = o.setContext(this.getContext(x)),
                            e = t.lineWidth,
                            s = t.color,
                            n = t.borderDash || [],
                            a = t.borderDashOffset,
                            r = t.tickWidth,
                            c = t.tickColor,
                            d = t.tickBorderDash || [],
                            f = t.tickBorderDashOffset;
                        _ = Ns(this, x, l), void 0 !== _ && (y = ve(i, _, e), h ? v = M = S = D = y : w = k = P = O = y, u.push({
                            tx1: v,
                            ty1: w,
                            tx2: M,
                            ty2: k,
                            x1: S,
                            y1: P,
                            x2: D,
                            y2: O,
                            width: e,
                            color: s,
                            borderDash: n,
                            borderDashOffset: a,
                            tickWidth: r,
                            tickColor: c,
                            tickBorderDash: d,
                            tickBorderDashOffset: f
                        }))
                    }
                    return this._ticksLength = c, this._borderValue = b, u
                }
                _computeLabelItems(t) {
                    const e = this.axis,
                        i = this.options,
                        {
                            position: o,
                            ticks: a
                        } = i,
                        r = this.isHorizontal(),
                        l = this.ticks,
                        {
                            align: h,
                            crossAlign: c,
                            padding: d,
                            mirror: u
                        } = a,
                        f = Ws(i.grid),
                        g = f + d,
                        p = u ? -d : g,
                        m = -H(this.labelRotation),
                        b = [];
                    let x, _, y, v, w, M, k, S, P, D, O, C, A = "middle";
                    if ("top" === o) M = this.bottom - p, k = this._getXAxisLabelAlignment();
                    else if ("bottom" === o) M = this.top + p, k = this._getXAxisLabelAlignment();
                    else if ("left" === o) {
                        const t = this._getYAxisLabelAlignment(f);
                        k = t.textAlign, w = t.x
                    } else if ("right" === o) {
                        const t = this._getYAxisLabelAlignment(f);
                        k = t.textAlign, w = t.x
                    } else if ("x" === e) {
                        if ("center" === o) M = (t.top + t.bottom) / 2 + g;
                        else if (n(o)) {
                            const t = Object.keys(o)[0],
                                e = o[t];
                            M = this.chart.scales[t].getPixelForValue(e) + g
                        }
                        k = this._getXAxisLabelAlignment()
                    } else if ("y" === e) {
                        if ("center" === o) w = (t.left + t.right) / 2 - g;
                        else if (n(o)) {
                            const t = Object.keys(o)[0],
                                e = o[t];
                            w = this.chart.scales[t].getPixelForValue(e)
                        }
                        k = this._getYAxisLabelAlignment(f).textAlign
                    }
                    "y" === e && ("start" === h ? A = "top" : "end" === h && (A = "bottom"));
                    const T = this._getLabelSizes();
                    for (x = 0, _ = l.length; x < _; ++x) {
                        y = l[x], v = y.label;
                        const t = a.setContext(this.getContext(x));
                        S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, O = s(v) ? v.length : 1;
                        const e = O / 2,
                            i = t.color,
                            n = t.textStrokeColor,
                            h = t.textStrokeWidth;
                        let d, f = k;
                        if (r ? (w = S, "inner" === k && (f = x === _ - 1 ? this.options.reverse ? "left" : "right" : 0 === x ? this.options.reverse ? "right" : "left" : "center"), C = "top" === o ? "near" === c || 0 !== m ? -O * D + D / 2 : "center" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : "near" === c || 0 !== m ? D / 2 : "center" === c ? T.highest.height / 2 - e * D : T.highest.height - O * D, u && (C *= -1)) : (M = S, C = (1 - O) * D / 2), t.showLabelBackdrop) {
                            const e = pi(t.backdropPadding),
                                i = T.heights[x],
                                s = T.widths[x];
                            let n = M + C - e.top,
                                o = w - e.left;
                            switch (A) {
                                case "middle":
                                    n -= i / 2;
                                    break;
                                case "bottom":
                                    n -= i
                            }
                            switch (k) {
                                case "center":
                                    o -= s / 2;
                                    break;
                                case "right":
                                    o -= s
                            }
                            d = {
                                left: o,
                                top: n,
                                width: s + e.width,
                                height: i + e.height,
                                color: t.backdropColor
                            }
                        }
                        b.push({
                            rotation: m,
                            label: v,
                            font: P,
                            color: i,
                            strokeColor: n,
                            strokeWidth: h,
                            textOffset: C,
                            textAlign: f,
                            textBaseline: A,
                            translation: [w, M],
                            backdrop: d
                        })
                    }
                    return b
                }
                _getXAxisLabelAlignment() {
                    const {
                        position: t,
                        ticks: e
                    } = this.options;
                    if (-H(this.labelRotation)) return "top" === t ? "left" : "right";
                    let i = "center";
                    return "start" === e.align ? i = "left" : "end" === e.align ? i = "right" : "inner" === e.align && (i = "inner"), i
                }
                _getYAxisLabelAlignment(t) {
                    const {
                        position: e,
                        ticks: {
                            crossAlign: i,
                            mirror: s,
                            padding: n
                        }
                    } = this.options, o = t + n, a = this._getLabelSizes().widest.width;
                    let r, l;
                    return "left" === e ? s ? (l = this.right + n, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l += a)) : (l = this.right - o, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l = this.left)) : "right" === e ? s ? (l = this.left + n, "near" === i ? r = "right" : "center" === i ? (r = "center", l -= a / 2) : (r = "left", l -= a)) : (l = this.left + o, "near" === i ? r = "left" : "center" === i ? (r = "center", l += a / 2) : (r = "right", l = this.right)) : r = "right", {
                        textAlign: r,
                        x: l
                    }
                }
                _computeLabelArea() {
                    if (this.options.ticks.mirror) return;
                    const t = this.chart,
                        e = this.options.position;
                    return "left" === e || "right" === e ? {
                        top: 0,
                        left: this.left,
                        bottom: t.height,
                        right: this.right
                    } : "top" === e || "bottom" === e ? {
                        top: this.top,
                        left: 0,
                        bottom: this.bottom,
                        right: t.width
                    } : void 0
                }
                drawBackground() {
                    const {
                        ctx: t,
                        options: {
                            backgroundColor: e
                        },
                        left: i,
                        top: s,
                        width: n,
                        height: o
                    } = this;
                    e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore())
                }
                getLineWidthForValue(t) {
                    const e = this.options.grid;
                    if (!this._isVisible() || !e.display) return 0;
                    const i = this.ticks.findIndex((e => e.value === t));
                    if (i >= 0) {
                        return e.setContext(this.getContext(i)).lineWidth
                    }
                    return 0
                }
                drawGrid(t) {
                    const e = this.options.grid,
                        i = this.ctx,
                        s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
                    let n, o;
                    const a = (t, e, s) => {
                        s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore())
                    };
                    if (e.display)
                        for (n = 0, o = s.length; n < o; ++n) {
                            const t = s[n];
                            e.drawOnChartArea && a({
                                x: t.x1,
                                y: t.y1
                            }, {
                                x: t.x2,
                                y: t.y2
                            }, t), e.drawTicks && a({
                                x: t.tx1,
                                y: t.ty1
                            }, {
                                x: t.tx2,
                                y: t.ty2
                            }, {
                                color: t.tickColor,
                                width: t.tickWidth,
                                borderDash: t.tickBorderDash,
                                borderDashOffset: t.tickBorderDashOffset
                            })
                        }
                }
                drawBorder() {
                    const {
                        chart: t,
                        ctx: e,
                        options: {
                            grid: i
                        }
                    } = this, s = i.setContext(this.getContext()), n = i.drawBorder ? s.borderWidth : 0;
                    if (!n) return;
                    const o = i.setContext(this.getContext(0)).lineWidth,
                        a = this._borderValue;
                    let r, l, h, c;
                    this.isHorizontal() ? (r = ve(t, this.left, n) - n / 2, l = ve(t, this.right, o) + o / 2, h = c = a) : (h = ve(t, this.top, n) - n / 2, c = ve(t, this.bottom, o) + o / 2, r = l = a), e.save(), e.lineWidth = s.borderWidth, e.strokeStyle = s.borderColor, e.beginPath(), e.moveTo(r, h), e.lineTo(l, c), e.stroke(), e.restore()
                }
                drawLabels(t) {
                    if (!this.options.ticks.display) return;
                    const e = this.ctx,
                        i = this._computeLabelArea();
                    i && Pe(e, i);
                    const s = this._labelItems || (this._labelItems = this._computeLabelItems(t));
                    let n, o;
                    for (n = 0, o = s.length; n < o; ++n) {
                        const t = s[n],
                            i = t.font,
                            o = t.label;
                        t.backdrop && (e.fillStyle = t.backdrop.color, e.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height)), Ae(e, o, 0, t.textOffset, i, t)
                    }
                    i && De(e)
                }
                drawTitle() {
                    const {
                        ctx: t,
                        options: {
                            position: e,
                            title: i,
                            reverse: o
                        }
                    } = this;
                    if (!i.display) return;
                    const a = mi(i.font),
                        r = pi(i.padding),
                        l = i.align;
                    let h = a.lineHeight / 2;
                    "bottom" === e || "center" === e || n(e) ? (h += r.bottom, s(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;
                    const {
                        titleX: c,
                        titleY: d,
                        maxWidth: u,
                        rotation: f
                    } = function (t, e, i, s) {
                        const {
                            top: o,
                            left: a,
                            bottom: r,
                            right: l,
                            chart: h
                        } = t, {
                            chartArea: c,
                            scales: d
                        } = h;
                        let u, f, g, p = 0;
                        const m = r - o,
                            b = l - a;
                        if (t.isHorizontal()) {
                            if (f = ut(s, a, l), n(i)) {
                                const t = Object.keys(i)[0],
                                    s = i[t];
                                g = d[t].getPixelForValue(s) + m - e
                            } else g = "center" === i ? (c.bottom + c.top) / 2 + m - e : Vs(t, i, e);
                            u = l - a
                        } else {
                            if (n(i)) {
                                const t = Object.keys(i)[0],
                                    s = i[t];
                                f = d[t].getPixelForValue(s) - b + e
                            } else f = "center" === i ? (c.left + c.right) / 2 - b + e : Vs(t, i, e);
                            g = ut(s, r, o), p = "left" === i ? -L : L
                        }
                        return {
                            titleX: f,
                            titleY: g,
                            maxWidth: u,
                            rotation: p
                        }
                    }(this, h, e, l);
                    Ae(t, i.text, 0, 0, a, {
                        color: i.color,
                        maxWidth: u,
                        rotation: f,
                        textAlign: Hs(l, e, o),
                        textBaseline: "middle",
                        translation: [c, d]
                    })
                }
                draw(t) {
                    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
                }
                _layers() {
                    const t = this.options,
                        e = t.ticks && t.ticks.z || 0,
                        i = r(t.grid && t.grid.z, -1);
                    return this._isVisible() && this.draw === $s.prototype.draw ? [{
                        z: i,
                        draw: t => {
                            this.drawBackground(), this.drawGrid(t), this.drawTitle()
                        }
                    }, {
                        z: i + 1,
                        draw: () => {
                            this.drawBorder()
                        }
                    }, {
                        z: e,
                        draw: t => {
                            this.drawLabels(t)
                        }
                    }] : [{
                        z: e,
                        draw: t => {
                            this.draw(t)
                        }
                    }]
                }
                getMatchingVisibleMetas(t) {
                    const e = this.chart.getSortedVisibleDatasetMetas(),
                        i = this.axis + "AxisID",
                        s = [];
                    let n, o;
                    for (n = 0, o = e.length; n < o; ++n) {
                        const o = e[n];
                        o[i] !== this.id || t && o.type !== t || s.push(o)
                    }
                    return s
                }
                _resolveTickFontOptions(t) {
                    return mi(this.options.ticks.setContext(this.getContext(t)).font)
                }
                _maxDigits() {
                    const t = this._resolveTickFontOptions(0).lineHeight;
                    return (this.isHorizontal() ? this.width : this.height) / t
                }
            }
            class Ys {
                constructor(t, e, i) {
                    this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
                }
                isForType(t) {
                    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
                }
                register(t) {
                    const e = Object.getPrototypeOf(t);
                    let i;
                    (function (t) {
                        return "id" in t && "defaults" in t
                    })(e) && (i = this.register(e));
                    const s = this.items,
                        n = t.id,
                        o = this.scope + "." + n;
                    if (!n) throw new Error("class does not have id: " + t);
                    return n in s || (s[n] = t, function (t, e, i) {
                        const s = m(Object.create(null), [i ? ne.get(i) : {}, ne.get(e), t.defaults]);
                        ne.set(e, s), t.defaultRoutes && function (t, e) {
                            Object.keys(e).forEach((i => {
                                const s = i.split("."),
                                    n = s.pop(),
                                    o = [t].concat(s).join("."),
                                    a = e[i].split("."),
                                    r = a.pop(),
                                    l = a.join(".");
                                ne.route(o, n, l, r)
                            }))
                        }(e, t.defaultRoutes);
                        t.descriptors && ne.describe(e, t.descriptors)
                    }(t, o, i), this.override && ne.override(t.id, t.overrides)), o
                }
                get(t) {
                    return this.items[t]
                }
                unregister(t) {
                    const e = this.items,
                        i = t.id,
                        s = this.scope;
                    i in e && delete e[i], s && i in ne[s] && (delete ne[s][i], this.override && delete te[i])
                }
            }
            var Us = new class {
                constructor() {
                    this.controllers = new Ys(Ls, "datasets", !0), this.elements = new Ys(Es, "elements"), this.plugins = new Ys(Object, "plugins"), this.scales = new Ys($s, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
                }
                add(...t) {
                    this._each("register", t)
                }
                remove(...t) {
                    this._each("unregister", t)
                }
                addControllers(...t) {
                    this._each("register", t, this.controllers)
                }
                addElements(...t) {
                    this._each("register", t, this.elements)
                }
                addPlugins(...t) {
                    this._each("register", t, this.plugins)
                }
                addScales(...t) {
                    this._each("register", t, this.scales)
                }
                getController(t) {
                    return this._get(t, this.controllers, "controller")
                }
                getElement(t) {
                    return this._get(t, this.elements, "element")
                }
                getPlugin(t) {
                    return this._get(t, this.plugins, "plugin")
                }
                getScale(t) {
                    return this._get(t, this.scales, "scale")
                }
                removeControllers(...t) {
                    this._each("unregister", t, this.controllers)
                }
                removeElements(...t) {
                    this._each("unregister", t, this.elements)
                }
                removePlugins(...t) {
                    this._each("unregister", t, this.plugins)
                }
                removeScales(...t) {
                    this._each("unregister", t, this.scales)
                }
                _each(t, e, i) {
                    [...e].forEach((e => {
                        const s = i || this._getRegistryForType(e);
                        i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : d(e, (e => {
                            const s = i || this._getRegistryForType(e);
                            this._exec(t, s, e)
                        }))
                    }))
                }
                _exec(t, e, i) {
                    const s = w(t);
                    c(i["before" + s], [], i), e[t](i), c(i["after" + s], [], i)
                }
                _getRegistryForType(t) {
                    for (let e = 0; e < this._typedRegistries.length; e++) {
                        const i = this._typedRegistries[e];
                        if (i.isForType(t)) return i
                    }
                    return this.plugins
                }
                _get(t, e, i) {
                    const s = e.get(t);
                    if (void 0 === s) throw new Error('"' + t + '" is not a registered ' + i + ".");
                    return s
                }
            };
            class Xs {
                constructor() {
                    this._init = []
                }
                notify(t, e, i, s) {
                    "beforeInit" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
                    const n = s ? this._descriptors(t).filter(s) : this._descriptors(t),
                        o = this._notify(n, t, e, i);
                    return "afterDestroy" === e && (this._notify(n, t, "stop"), this._notify(this._init, t, "uninstall")), o
                }
                _notify(t, e, i, s) {
                    s = s || {};
                    for (const n of t) {
                        const t = n.plugin;
                        if (!1 === c(t[i], [e, s, n.options], t) && s.cancelable) return !1
                    }
                    return !0
                }
                invalidate() {
                    i(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
                }
                _descriptors(t) {
                    if (this._cache) return this._cache;
                    const e = this._cache = this._createDescriptors(t);
                    return this._notifyStateChanges(t), e
                }
                _createDescriptors(t, e) {
                    const i = t && t.config,
                        s = r(i.options && i.options.plugins, {}),
                        n = function (t) {
                            const e = {},
                                i = [],
                                s = Object.keys(Us.plugins.items);
                            for (let t = 0; t < s.length; t++) i.push(Us.getPlugin(s[t]));
                            const n = t.plugins || [];
                            for (let t = 0; t < n.length; t++) {
                                const s = n[t]; - 1 === i.indexOf(s) && (i.push(s), e[s.id] = !0)
                            }
                            return {
                                plugins: i,
                                localIds: e
                            }
                        }(i);
                    return !1 !== s || e ? function (t, {
                        plugins: e,
                        localIds: i
                    }, s, n) {
                        const o = [],
                            a = t.getContext();
                        for (const r of e) {
                            const e = r.id,
                                l = qs(s[e], n);
                            null !== l && o.push({
                                plugin: r,
                                options: Ks(t.config, {
                                    plugin: r,
                                    local: i[e]
                                }, l, a)
                            })
                        }
                        return o
                    }(t, n, s, e) : []
                }
                _notifyStateChanges(t) {
                    const e = this._oldCache || [],
                        i = this._cache,
                        s = (t, e) => t.filter((t => !e.some((e => t.plugin.id === e.plugin.id))));
                    this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start")
                }
            }

            function qs(t, e) {
                return e || !1 !== t ? !0 === t ? {} : t : null
            }

            function Ks(t, {
                plugin: e,
                local: i
            }, s, n) {
                const o = t.pluginScopeKeys(e),
                    a = t.getOptionScopes(s, o);
                return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [""], {
                    scriptable: !1,
                    indexable: !1,
                    allKeys: !0
                })
            }

            function Gs(t, e) {
                const i = ne.datasets[t] || {};
                return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
            }

            function Zs(t, e) {
                return "x" === t || "y" === t ? t : e.axis || ("top" === (i = e.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.charAt(0).toLowerCase();
                var i
            }

            function Js(t) {
                const e = t.options || (t.options = {});
                e.plugins = r(e.plugins, {}), e.scales = function (t, e) {
                    const i = te[t.type] || {
                            scales: {}
                        },
                        s = e.scales || {},
                        o = Gs(t.type, e),
                        a = Object.create(null),
                        r = Object.create(null);
                    return Object.keys(s).forEach((t => {
                        const e = s[t];
                        if (!n(e)) return console.error(`Invalid scale configuration for scale: ${t}`);
                        if (e._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${t}`);
                        const l = Zs(t, e),
                            h = function (t, e) {
                                return t === e ? "_index_" : "_value_"
                            }(l, o),
                            c = i.scales || {};
                        a[l] = a[l] || t, r[t] = b(Object.create(null), [{
                            axis: l
                        }, e, c[l], c[h]])
                    })), t.data.datasets.forEach((i => {
                        const n = i.type || t.type,
                            o = i.indexAxis || Gs(n, e),
                            l = (te[n] || {}).scales || {};
                        Object.keys(l).forEach((t => {
                            const e = function (t, e) {
                                    let i = t;
                                    return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
                                }(t, o),
                                n = i[e + "AxisID"] || a[e] || e;
                            r[n] = r[n] || Object.create(null), b(r[n], [{
                                axis: e
                            }, s[n], l[t]])
                        }))
                    })), Object.keys(r).forEach((t => {
                        const e = r[t];
                        b(e, [ne.scales[e.type], ne.scale])
                    })), r
                }(t, e)
            }

            function Qs(t) {
                return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
            }
            const tn = new Map,
                en = new Set;

            function sn(t, e) {
                let i = tn.get(t);
                return i || (i = e(), tn.set(t, i), en.add(i)), i
            }
            const nn = (t, e, i) => {
                const s = y(e, i);
                void 0 !== s && t.add(s)
            };
            class on {
                constructor(t) {
                    this._config = function (t) {
                        return (t = t || {}).data = Qs(t.data), Js(t), t
                    }(t), this._scopeCache = new Map, this._resolverCache = new Map
                }
                get platform() {
                    return this._config.platform
                }
                get type() {
                    return this._config.type
                }
                set type(t) {
                    this._config.type = t
                }
                get data() {
                    return this._config.data
                }
                set data(t) {
                    this._config.data = Qs(t)
                }
                get options() {
                    return this._config.options
                }
                set options(t) {
                    this._config.options = t
                }
                get plugins() {
                    return this._config.plugins
                }
                update() {
                    const t = this._config;
                    this.clearCache(), Js(t)
                }
                clearCache() {
                    this._scopeCache.clear(), this._resolverCache.clear()
                }
                datasetScopeKeys(t) {
                    return sn(t, (() => [
                        [`datasets.${t}`, ""]
                    ]))
                }
                datasetAnimationScopeKeys(t, e) {
                    return sn(`${t}.transition.${e}`, (() => [
                        [`datasets.${t}.transitions.${e}`, `transitions.${e}`],
                        [`datasets.${t}`, ""]
                    ]))
                }
                datasetElementScopeKeys(t, e) {
                    return sn(`${t}-${e}`, (() => [
                        [`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]
                    ]))
                }
                pluginScopeKeys(t) {
                    const e = t.id;
                    return sn(`${this.type}-plugin-${e}`, (() => [
                        [`plugins.${e}`, ...t.additionalOptionScopes || []]
                    ]))
                }
                _cachedScopes(t, e) {
                    const i = this._scopeCache;
                    let s = i.get(t);
                    return s && !e || (s = new Map, i.set(t, s)), s
                }
                getOptionScopes(t, e, i) {
                    const {
                        options: s,
                        type: n
                    } = this, o = this._cachedScopes(t, i), a = o.get(e);
                    if (a) return a;
                    const r = new Set;
                    e.forEach((e => {
                        t && (r.add(t), e.forEach((e => nn(r, t, e)))), e.forEach((t => nn(r, s, t))), e.forEach((t => nn(r, te[n] || {}, t))), e.forEach((t => nn(r, ne, t))), e.forEach((t => nn(r, ee, t)))
                    }));
                    const l = Array.from(r);
                    return 0 === l.length && l.push(Object.create(null)), en.has(e) && o.set(e, l), l
                }
                chartOptionScopes() {
                    const {
                        options: t,
                        type: e
                    } = this;
                    return [t, te[e] || {}, ne.datasets[e] || {}, {
                        type: e
                    }, ne, ee]
                }
                resolveNamedOptions(t, e, i, n = [""]) {
                    const o = {
                            $shared: !0
                        },
                        {
                            resolver: a,
                            subPrefixes: r
                        } = an(this._resolverCache, t, n);
                    let l = a;
                    if (function (t, e) {
                            const {
                                isScriptable: i,
                                isIndexable: n
                            } = Ie(t);
                            for (const o of e) {
                                const e = i(o),
                                    a = n(o),
                                    r = (a || e) && t[o];
                                if (e && (k(r) || rn(r)) || a && s(r)) return !0
                            }
                            return !1
                        }(a, e)) {
                        o.$shared = !1;
                        l = Re(a, i = k(i) ? i() : i, this.createResolver(t, i, r))
                    }
                    for (const t of e) o[t] = l[t];
                    return o
                }
                createResolver(t, e, i = [""], s) {
                    const {
                        resolver: o
                    } = an(this._resolverCache, t, i);
                    return n(e) ? Re(o, e, void 0, s) : o
                }
            }

            function an(t, e, i) {
                let s = t.get(e);
                s || (s = new Map, t.set(e, s));
                const n = i.join();
                let o = s.get(n);
                if (!o) {
                    o = {
                        resolver: Ee(e, i),
                        subPrefixes: i.filter((t => !t.toLowerCase().includes("hover")))
                    }, s.set(n, o)
                }
                return o
            }
            const rn = t => n(t) && Object.getOwnPropertyNames(t).reduce(((e, i) => e || k(t[i])), !1);
            const ln = ["top", "bottom", "left", "right", "chartArea"];

            function hn(t, e) {
                return "top" === t || "bottom" === t || -1 === ln.indexOf(t) && "x" === e
            }

            function cn(t, e) {
                return function (i, s) {
                    return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t]
                }
            }

            function dn(t) {
                const e = t.chart,
                    i = e.options.animation;
                e.notifyPlugins("afterRender"), c(i && i.onComplete, [t], e)
            }

            function un(t) {
                const e = t.chart,
                    i = e.options.animation;
                c(i && i.onProgress, [t], e)
            }

            function fn(t) {
                return oe() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t
            }
            const gn = {},
                pn = t => {
                    const e = fn(t);
                    return Object.values(gn).filter((t => t.canvas === e)).pop()
                };

            function mn(t, e, i) {
                const s = Object.keys(t);
                for (const n of s) {
                    const s = +n;
                    if (s >= e) {
                        const o = t[n];
                        delete t[n], (i > 0 || s > e) && (t[s + i] = o)
                    }
                }
            }
            class bn {
                constructor(t, i) {
                    const s = this.config = new on(i),
                        n = fn(t),
                        o = pn(n);
                    if (o) throw new Error("Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused.");
                    const a = s.createResolver(s.chartOptionScopes(), this.getContext());
                    this.platform = new(s.platform || gs(n)), this.platform.updateConfig(s);
                    const r = this.platform.acquireContext(n, a.aspectRatio),
                        l = r && r.canvas,
                        h = l && l.height,
                        c = l && l.width;
                    this.id = e(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new Xs, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = ct((t => this.update(t)), a.resizeDelay || 0), this._dataChanges = [], gn[this.id] = this, r && l ? (mt.listen(this, "complete", dn), mt.listen(this, "progress", un), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item")
                }
                get aspectRatio() {
                    const {
                        options: {
                            aspectRatio: t,
                            maintainAspectRatio: e
                        },
                        width: s,
                        height: n,
                        _aspectRatio: o
                    } = this;
                    return i(t) ? e && o ? o : n ? s / n : null : t
                }
                get data() {
                    return this.config.data
                }
                set data(t) {
                    this.config.data = t
                }
                get options() {
                    return this._options
                }
                set options(t) {
                    this.config.options = t
                }
                _initialize() {
                    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : pe(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
                }
                clear() {
                    return we(this.canvas, this.ctx), this
                }
                stop() {
                    return mt.stop(this), this
                }
                resize(t, e) {
                    mt.running(this) ? this._resizeBeforeDraw = {
                        width: t,
                        height: e
                    } : this._resize(t, e)
                }
                _resize(t, e) {
                    const i = this.options,
                        s = this.canvas,
                        n = i.maintainAspectRatio && this.aspectRatio,
                        o = this.platform.getMaximumSize(s, t, e, n),
                        a = i.devicePixelRatio || this.platform.getDevicePixelRatio(),
                        r = this.width ? "resize" : "attach";
                    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, pe(this, a, !0) && (this.notifyPlugins("resize", {
                        size: o
                    }), c(i.onResize, [this, o], this), this.attached && this._doResize(r) && this.render())
                }
                ensureScalesHaveIDs() {
                    d(this.options.scales || {}, ((t, e) => {
                        t.id = e
                    }))
                }
                buildOrUpdateScales() {
                    const t = this.options,
                        e = t.scales,
                        i = this.scales,
                        s = Object.keys(i).reduce(((t, e) => (t[e] = !1, t)), {});
                    let n = [];
                    e && (n = n.concat(Object.keys(e).map((t => {
                        const i = e[t],
                            s = Zs(t, i),
                            n = "r" === s,
                            o = "x" === s;
                        return {
                            options: i,
                            dposition: n ? "chartArea" : o ? "bottom" : "left",
                            dtype: n ? "radialLinear" : o ? "category" : "linear"
                        }
                    })))), d(n, (e => {
                        const n = e.options,
                            o = n.id,
                            a = Zs(o, n),
                            l = r(n.type, e.dtype);
                        void 0 !== n.position && hn(n.position, a) === hn(e.dposition) || (n.position = e.dposition), s[o] = !0;
                        let h = null;
                        if (o in i && i[o].type === l) h = i[o];
                        else {
                            h = new(Us.getScale(l))({
                                id: o,
                                type: l,
                                ctx: this.ctx,
                                chart: this
                            }), i[h.id] = h
                        }
                        h.init(n, t)
                    })), d(s, ((t, e) => {
                        t || delete i[e]
                    })), d(i, (t => {
                        Zi.configure(this, t, t.options), Zi.addBox(this, t)
                    }))
                }
                _updateMetasets() {
                    const t = this._metasets,
                        e = this.data.datasets.length,
                        i = t.length;
                    if (t.sort(((t, e) => t.index - e.index)), i > e) {
                        for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
                        t.splice(e, i - e)
                    }
                    this._sortedMetasets = t.slice(0).sort(cn("order", "index"))
                }
                _removeUnreferencedMetasets() {
                    const {
                        _metasets: t,
                        data: {
                            datasets: e
                        }
                    } = this;
                    t.length > e.length && delete this._stacks, t.forEach(((t, i) => {
                        0 === e.filter((e => e === t._dataset)).length && this._destroyDatasetMeta(i)
                    }))
                }
                buildOrUpdateControllers() {
                    const t = [],
                        e = this.data.datasets;
                    let i, s;
                    for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {
                        const s = e[i];
                        let n = this.getDatasetMeta(i);
                        const o = s.type || this.config.type;
                        if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || Gs(o, this.options), n.order = s.order || 0, n.index = i, n.label = "" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();
                        else {
                            const e = Us.getController(o),
                                {
                                    datasetElementType: s,
                                    dataElementType: a
                                } = ne.datasets[o];
                            Object.assign(e.prototype, {
                                dataElementType: Us.getElement(a),
                                datasetElementType: s && Us.getElement(s)
                            }), n.controller = new e(this, i), t.push(n.controller)
                        }
                    }
                    return this._updateMetasets(), t
                }
                _resetElements() {
                    d(this.data.datasets, ((t, e) => {
                        this.getDatasetMeta(e).controller.reset()
                    }), this)
                }
                reset() {
                    this._resetElements(), this.notifyPlugins("reset")
                }
                update(t) {
                    const e = this.config;
                    e.update();
                    const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),
                        s = this._animationsDisabled = !i.animation;
                    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", {
                            mode: t,
                            cancelable: !0
                        })) return;
                    const n = this.buildOrUpdateControllers();
                    this.notifyPlugins("beforeElementsUpdate");
                    let o = 0;
                    for (let t = 0, e = this.data.datasets.length; t < e; t++) {
                        const {
                            controller: e
                        } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);
                        e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o)
                    }
                    o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || d(n, (t => {
                        t.reset()
                    })), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
                        mode: t
                    }), this._layers.sort(cn("z", "_idx"));
                    const {
                        _active: a,
                        _lastEvent: r
                    } = this;
                    r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render()
                }
                _updateScales() {
                    d(this.scales, (t => {
                        Zi.removeBox(this, t)
                    })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales()
                }
                _checkEventBindings() {
                    const t = this.options,
                        e = new Set(Object.keys(this._listeners)),
                        i = new Set(t.events);
                    S(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents())
                }
                _updateHiddenIndices() {
                    const {
                        _hiddenIndices: t
                    } = this, e = this._getUniformDataChanges() || [];
                    for (const {
                            method: i,
                            start: s,
                            count: n
                        } of e) {
                        mn(t, s, "_removeElements" === i ? -n : n)
                    }
                }
                _getUniformDataChanges() {
                    const t = this._dataChanges;
                    if (!t || !t.length) return;
                    this._dataChanges = [];
                    const e = this.data.datasets.length,
                        i = e => new Set(t.filter((t => t[0] === e)).map(((t, e) => e + "," + t.splice(1).join(",")))),
                        s = i(0);
                    for (let t = 1; t < e; t++)
                        if (!S(s, i(t))) return;
                    return Array.from(s).map((t => t.split(","))).map((t => ({
                        method: t[1],
                        start: +t[2],
                        count: +t[3]
                    })))
                }
                _updateLayout(t) {
                    if (!1 === this.notifyPlugins("beforeLayout", {
                            cancelable: !0
                        })) return;
                    Zi.update(this, this.width, this.height, t);
                    const e = this.chartArea,
                        i = e.width <= 0 || e.height <= 0;
                    this._layers = [], d(this.boxes, (t => {
                        i && "chartArea" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()))
                    }), this), this._layers.forEach(((t, e) => {
                        t._idx = e
                    })), this.notifyPlugins("afterLayout")
                }
                _updateDatasets(t) {
                    if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
                            mode: t,
                            cancelable: !0
                        })) {
                        for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();
                        for (let e = 0, i = this.data.datasets.length; e < i; ++e) this._updateDataset(e, k(t) ? t({
                            datasetIndex: e
                        }) : t);
                        this.notifyPlugins("afterDatasetsUpdate", {
                            mode: t
                        })
                    }
                }
                _updateDataset(t, e) {
                    const i = this.getDatasetMeta(t),
                        s = {
                            meta: i,
                            index: t,
                            mode: e,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s))
                }
                render() {
                    !1 !== this.notifyPlugins("beforeRender", {
                        cancelable: !0
                    }) && (mt.has(this) ? this.attached && !mt.running(this) && mt.start(this) : (this.draw(), dn({
                        chart: this
                    })))
                }
                draw() {
                    let t;
                    if (this._resizeBeforeDraw) {
                        const {
                            width: t,
                            height: e
                        } = this._resizeBeforeDraw;
                        this._resize(t, e), this._resizeBeforeDraw = null
                    }
                    if (this.clear(), this.width <= 0 || this.height <= 0) return;
                    if (!1 === this.notifyPlugins("beforeDraw", {
                            cancelable: !0
                        })) return;
                    const e = this._layers;
                    for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);
                    for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);
                    this.notifyPlugins("afterDraw")
                }
                _getSortedDatasetMetas(t) {
                    const e = this._sortedMetasets,
                        i = [];
                    let s, n;
                    for (s = 0, n = e.length; s < n; ++s) {
                        const n = e[s];
                        t && !n.visible || i.push(n)
                    }
                    return i
                }
                getSortedVisibleDatasetMetas() {
                    return this._getSortedDatasetMetas(!0)
                }
                _drawDatasets() {
                    if (!1 === this.notifyPlugins("beforeDatasetsDraw", {
                            cancelable: !0
                        })) return;
                    const t = this.getSortedVisibleDatasetMetas();
                    for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);
                    this.notifyPlugins("afterDatasetsDraw")
                }
                _drawDataset(t) {
                    const e = this.ctx,
                        i = t._clip,
                        s = !i.disabled,
                        n = this.chartArea,
                        o = {
                            meta: t,
                            index: t.index,
                            cancelable: !0
                        };
                    !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (s && Pe(e, {
                        left: !1 === i.left ? 0 : n.left - i.left,
                        right: !1 === i.right ? this.width : n.right + i.right,
                        top: !1 === i.top ? 0 : n.top - i.top,
                        bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom
                    }), t.controller.draw(), s && De(e), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o))
                }
                isPointInArea(t) {
                    return Se(t, this.chartArea, this._minPadding)
                }
                getElementsAtEventForMode(t, e, i, s) {
                    const n = Vi.modes[e];
                    return "function" == typeof n ? n(this, t, i, s) : []
                }
                getDatasetMeta(t) {
                    const e = this.data.datasets[t],
                        i = this._metasets;
                    let s = i.filter((t => t && t._dataset === e)).pop();
                    return s || (s = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: e && e.order || 0,
                        index: t,
                        _dataset: e,
                        _parsed: [],
                        _sorted: !1
                    }, i.push(s)), s
                }
                getContext() {
                    return this.$context || (this.$context = _i(null, {
                        chart: this,
                        type: "chart"
                    }))
                }
                getVisibleDatasetCount() {
                    return this.getSortedVisibleDatasetMetas().length
                }
                isDatasetVisible(t) {
                    const e = this.data.datasets[t];
                    if (!e) return !1;
                    const i = this.getDatasetMeta(t);
                    return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden
                }
                setDatasetVisibility(t, e) {
                    this.getDatasetMeta(t).hidden = !e
                }
                toggleDataVisibility(t) {
                    this._hiddenIndices[t] = !this._hiddenIndices[t]
                }
                getDataVisibility(t) {
                    return !this._hiddenIndices[t]
                }
                _updateVisibility(t, e, i) {
                    const s = i ? "show" : "hide",
                        n = this.getDatasetMeta(t),
                        o = n.controller._resolveAnimations(void 0, s);
                    M(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {
                        visible: i
                    }), this.update((e => e.datasetIndex === t ? s : void 0)))
                }
                hide(t, e) {
                    this._updateVisibility(t, e, !1)
                }
                show(t, e) {
                    this._updateVisibility(t, e, !0)
                }
                _destroyDatasetMeta(t) {
                    const e = this._metasets[t];
                    e && e.controller && e.controller._destroy(), delete this._metasets[t]
                }
                _stop() {
                    let t, e;
                    for (this.stop(), mt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t)
                }
                destroy() {
                    this.notifyPlugins("beforeDestroy");
                    const {
                        canvas: t,
                        ctx: e
                    } = this;
                    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), we(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete gn[this.id], this.notifyPlugins("afterDestroy")
                }
                toBase64Image(...t) {
                    return this.canvas.toDataURL(...t)
                }
                bindEvents() {
                    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
                }
                bindUserEvents() {
                    const t = this._listeners,
                        e = this.platform,
                        i = (i, s) => {
                            e.addEventListener(this, i, s), t[i] = s
                        },
                        s = (t, e, i) => {
                            t.offsetX = e, t.offsetY = i, this._eventHandler(t)
                        };
                    d(this.options.events, (t => i(t, s)))
                }
                bindResponsiveEvents() {
                    this._responsiveListeners || (this._responsiveListeners = {});
                    const t = this._responsiveListeners,
                        e = this.platform,
                        i = (i, s) => {
                            e.addEventListener(this, i, s), t[i] = s
                        },
                        s = (i, s) => {
                            t[i] && (e.removeEventListener(this, i, s), delete t[i])
                        },
                        n = (t, e) => {
                            this.canvas && this.resize(t, e)
                        };
                    let o;
                    const a = () => {
                        s("attach", a), this.attached = !0, this.resize(), i("resize", n), i("detach", o)
                    };
                    o = () => {
                        this.attached = !1, s("resize", n), this._stop(), this._resize(0, 0), i("attach", a)
                    }, e.isAttached(this.canvas) ? a() : o()
                }
                unbindEvents() {
                    d(this._listeners, ((t, e) => {
                        this.platform.removeEventListener(this, e, t)
                    })), this._listeners = {}, d(this._responsiveListeners, ((t, e) => {
                        this.platform.removeEventListener(this, e, t)
                    })), this._responsiveListeners = void 0
                }
                updateHoverStyle(t, e, i) {
                    const s = i ? "set" : "remove";
                    let n, o, a, r;
                    for ("dataset" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) {
                        o = t[a];
                        const e = o && this.getDatasetMeta(o.datasetIndex).controller;
                        e && e[s + "HoverStyle"](o.element, o.datasetIndex, o.index)
                    }
                }
                getActiveElements() {
                    return this._active || []
                }
                setActiveElements(t) {
                    const e = this._active || [],
                        i = t.map((({
                            datasetIndex: t,
                            index: e
                        }) => {
                            const i = this.getDatasetMeta(t);
                            if (!i) throw new Error("No dataset found at index " + t);
                            return {
                                datasetIndex: t,
                                element: i.data[e],
                                index: e
                            }
                        }));
                    !u(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e))
                }
                notifyPlugins(t, e, i) {
                    return this._plugins.notify(this, t, e, i)
                }
                _updateHoverStyles(t, e, i) {
                    const s = this.options.hover,
                        n = (t, e) => t.filter((t => !e.some((e => t.datasetIndex === e.datasetIndex && t.index === e.index)))),
                        o = n(e, t),
                        a = i ? t : n(t, e);
                    o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0)
                }
                _eventHandler(t, e) {
                    const i = {
                            event: t,
                            replay: e,
                            cancelable: !0,
                            inChartArea: this.isPointInArea(t)
                        },
                        s = e => (e.options.events || this.options.events).includes(t.native.type);
                    if (!1 === this.notifyPlugins("beforeEvent", i, s)) return;
                    const n = this._handleEvent(t, e, i.inChartArea);
                    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (n || i.changed) && this.render(), this
                }
                _handleEvent(t, e, i) {
                    const {
                        _active: s = [],
                        options: n
                    } = this, o = e, a = this._getActiveElements(t, s, i, o), r = P(t), l = function (t, e, i, s) {
                        return i && "mouseout" !== t.type ? s ? e : t : null
                    }(t, this._lastEvent, i, r);
                    i && (this._lastEvent = null, c(n.onHover, [t, a, this], this), r && c(n.onClick, [t, a, this], this));
                    const h = !u(a, s);
                    return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h
                }
                _getActiveElements(t, e, i, s) {
                    if ("mouseout" === t.type) return [];
                    if (!i) return e;
                    const n = this.options.hover;
                    return this.getElementsAtEventForMode(t, n.mode, n, s)
                }
            }
            const xn = () => d(bn.instances, (t => t._plugins.invalidate())),
                _n = !0;

            function yn() {
                throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
            }
            Object.defineProperties(bn, {
                defaults: {
                    enumerable: _n,
                    value: ne
                },
                instances: {
                    enumerable: _n,
                    value: gn
                },
                overrides: {
                    enumerable: _n,
                    value: te
                },
                registry: {
                    enumerable: _n,
                    value: Us
                },
                version: {
                    enumerable: _n,
                    value: "3.9.1"
                },
                getChart: {
                    enumerable: _n,
                    value: pn
                },
                register: {
                    enumerable: _n,
                    value: (...t) => {
                        Us.add(...t), xn()
                    }
                },
                unregister: {
                    enumerable: _n,
                    value: (...t) => {
                        Us.remove(...t), xn()
                    }
                }
            });
            class vn {
                constructor(t) {
                    this.options = t || {}
                }
                init(t) {}
                formats() {
                    return yn()
                }
                parse(t, e) {
                    return yn()
                }
                format(t, e) {
                    return yn()
                }
                add(t, e, i) {
                    return yn()
                }
                diff(t, e, i) {
                    return yn()
                }
                startOf(t, e, i) {
                    return yn()
                }
                endOf(t, e) {
                    return yn()
                }
            }
            vn.override = function (t) {
                Object.assign(vn.prototype, t)
            };
            var wn = {
                _date: vn
            };

            function Mn(t) {
                const e = t.iScale,
                    i = function (t, e) {
                        if (!t._cache.$bar) {
                            const i = t.getMatchingVisibleMetas(e);
                            let s = [];
                            for (let e = 0, n = i.length; e < n; e++) s = s.concat(i[e].controller.getAllParsedValues(t));
                            t._cache.$bar = rt(s.sort(((t, e) => t - e)))
                        }
                        return t._cache.$bar
                    }(e, t.type);
                let s, n, o, a, r = e._length;
                const l = () => {
                    32767 !== o && -32768 !== o && (M(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o)
                };
                for (s = 0, n = i.length; s < n; ++s) o = e.getPixelForValue(i[s]), l();
                for (a = void 0, s = 0, n = e.ticks.length; s < n; ++s) o = e.getPixelForTick(s), l();
                return r
            }

            function kn(t, e, i, n) {
                return s(t) ? function (t, e, i, s) {
                    const n = i.parse(t[0], s),
                        o = i.parse(t[1], s),
                        a = Math.min(n, o),
                        r = Math.max(n, o);
                    let l = a,
                        h = r;
                    Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {
                        barStart: l,
                        barEnd: h,
                        start: n,
                        end: o,
                        min: a,
                        max: r
                    }
                }(t, e, i, n) : e[i.axis] = i.parse(t, n), e
            }

            function Sn(t, e, i, s) {
                const n = t.iScale,
                    o = t.vScale,
                    a = n.getLabels(),
                    r = n === o,
                    l = [];
                let h, c, d, u;
                for (h = i, c = i + s; h < c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(kn(u, d, o, h));
                return l
            }

            function Pn(t) {
                return t && void 0 !== t.barStart && void 0 !== t.barEnd
            }

            function Dn(t, e, i, s) {
                let n = e.borderSkipped;
                const o = {};
                if (!n) return void(t.borderSkipped = o);
                if (!0 === n) return void(t.borderSkipped = {
                    top: !0,
                    right: !0,
                    bottom: !0,
                    left: !0
                });
                const {
                    start: a,
                    end: r,
                    reverse: l,
                    top: h,
                    bottom: c
                } = function (t) {
                    let e, i, s, n, o;
                    return t.horizontal ? (e = t.base > t.x, i = "left", s = "right") : (e = t.base < t.y, i = "bottom", s = "top"), e ? (n = "end", o = "start") : (n = "start", o = "end"), {
                        start: i,
                        end: s,
                        reverse: e,
                        top: n,
                        bottom: o
                    }
                }(t);
                "middle" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[On(c, a, r, l)] = !0, n = h)), o[On(n, a, r, l)] = !0, t.borderSkipped = o
            }

            function On(t, e, i, s) {
                var n, o, a;
                return s ? (a = i, t = Cn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Cn(t, e, i), t
            }

            function Cn(t, e, i) {
                return "start" === t ? e : "end" === t ? i : t
            }

            function An(t, {
                inflateAmount: e
            }, i) {
                t.inflateAmount = "auto" === e ? 1 === i ? .33 : 0 : e
            }
            class Tn extends Ls {
                parsePrimitiveData(t, e, i, s) {
                    return Sn(t, e, i, s)
                }
                parseArrayData(t, e, i, s) {
                    return Sn(t, e, i, s)
                }
                parseObjectData(t, e, i, s) {
                    const {
                        iScale: n,
                        vScale: o
                    } = t, {
                        xAxisKey: a = "x",
                        yAxisKey: r = "y"
                    } = this._parsing, l = "x" === n.axis ? a : r, h = "x" === o.axis ? a : r, c = [];
                    let d, u, f, g;
                    for (d = i, u = i + s; d < u; ++d) g = e[d], f = {}, f[n.axis] = n.parse(y(g, l), d), c.push(kn(y(g, h), f, o, d));
                    return c
                }
                updateRangeFromParsed(t, e, i, s) {
                    super.updateRangeFromParsed(t, e, i, s);
                    const n = i._custom;
                    n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max))
                }
                getMaxOverflow() {
                    return 0
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        {
                            iScale: i,
                            vScale: s
                        } = e,
                        n = this.getParsed(t),
                        o = n._custom,
                        a = Pn(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(n[s.axis]);
                    return {
                        label: "" + i.getLabelForValue(n[i.axis]),
                        value: a
                    }
                }
                initialize() {
                    this.enableOptionSharing = !0, super.initialize();
                    this._cachedMeta.stack = this.getDataset().stack
                }
                update(t) {
                    const e = this._cachedMeta;
                    this.updateElements(e.data, 0, e.data.length, t)
                }
                updateElements(t, e, s, n) {
                    const o = "reset" === n,
                        {
                            index: a,
                            _cachedMeta: {
                                vScale: r
                            }
                        } = this,
                        l = r.getBasePixel(),
                        h = r.isHorizontal(),
                        c = this._getRuler(),
                        {
                            sharedOptions: d,
                            includeOptions: u
                        } = this._getSharedOptions(e, n);
                    for (let f = e; f < e + s; f++) {
                        const e = this.getParsed(f),
                            s = o || i(e[r.axis]) ? {
                                base: l,
                                head: l
                            } : this._calculateBarValuePixels(f),
                            g = this._calculateBarIndexPixels(f, c),
                            p = (e._stacks || {})[r.axis],
                            m = {
                                horizontal: h,
                                base: s.base,
                                enableBorderRadius: !p || Pn(e._custom) || a === p._top || a === p._bottom,
                                x: h ? s.head : g.center,
                                y: h ? g.center : s.head,
                                height: h ? g.size : Math.abs(s.size),
                                width: h ? Math.abs(s.size) : g.size
                            };
                        u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : n));
                        const b = m.options || t[f].options;
                        Dn(m, b, p, a), An(m, b, c.ratio), this.updateElement(t[f], f, m, n)
                    }
                }
                _getStacks(t, e) {
                    const {
                        iScale: s
                    } = this._cachedMeta, n = s.getMatchingVisibleMetas(this._type).filter((t => t.controller.options.grouped)), o = s.options.stacked, a = [], r = t => {
                        const s = t.controller.getParsed(e),
                            n = s && s[t.vScale.axis];
                        if (i(n) || isNaN(n)) return !0
                    };
                    for (const i of n)
                        if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;
                    return a.length || a.push(void 0), a
                }
                _getStackCount(t) {
                    return this._getStacks(void 0, t).length
                }
                _getStackIndex(t, e, i) {
                    const s = this._getStacks(t, i),
                        n = void 0 !== e ? s.indexOf(e) : -1;
                    return -1 === n ? s.length - 1 : n
                }
                _getRuler() {
                    const t = this.options,
                        e = this._cachedMeta,
                        i = e.iScale,
                        s = [];
                    let n, o;
                    for (n = 0, o = e.data.length; n < o; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
                    const a = t.barThickness;
                    return {
                        min: a || Mn(e),
                        pixels: s,
                        start: i._startPixel,
                        end: i._endPixel,
                        stackCount: this._getStackCount(),
                        scale: i,
                        grouped: t.grouped,
                        ratio: a ? 1 : t.categoryPercentage * t.barPercentage
                    }
                }
                _calculateBarValuePixels(t) {
                    const {
                        _cachedMeta: {
                            vScale: e,
                            _stacked: s
                        },
                        options: {
                            base: n,
                            minBarLength: o
                        }
                    } = this, a = n || 0, r = this.getParsed(t), l = r._custom, h = Pn(l);
                    let c, d, u = r[e.axis],
                        f = 0,
                        g = s ? this.applyStack(e, r, s) : u;
                    g !== u && (f = g - u, g = u), h && (u = l.barStart, g = l.barEnd - l.barStart, 0 !== u && z(u) !== z(l.barEnd) && (f = 0), f += u);
                    const p = i(n) || h ? f : n;
                    let m = e.getPixelForValue(p);
                    if (c = this.chart.getDataVisibility(t) ? e.getPixelForValue(f + g) : m, d = c - m, Math.abs(d) < o) {
                        d = function (t, e, i) {
                            return 0 !== t ? z(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1)
                        }(d, e, a) * o, u === a && (m -= d / 2);
                        const t = e.getPixelForDecimal(0),
                            i = e.getPixelForDecimal(1),
                            s = Math.min(t, i),
                            n = Math.max(t, i);
                        m = Math.max(Math.min(m, n), s), c = m + d
                    }
                    if (m === e.getPixelForValue(a)) {
                        const t = z(d) * e.getLineWidthForValue(a) / 2;
                        m += t, d -= t
                    }
                    return {
                        size: d,
                        base: m,
                        head: c,
                        center: c + d / 2
                    }
                }
                _calculateBarIndexPixels(t, e) {
                    const s = e.scale,
                        n = this.options,
                        o = n.skipNull,
                        a = r(n.maxBarThickness, 1 / 0);
                    let l, h;
                    if (e.grouped) {
                        const s = o ? this._getStackCount(t) : e.stackCount,
                            r = "flex" === n.barThickness ? function (t, e, i, s) {
                                const n = e.pixels,
                                    o = n[t];
                                let a = t > 0 ? n[t - 1] : null,
                                    r = t < n.length - 1 ? n[t + 1] : null;
                                const l = i.categoryPercentage;
                                null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);
                                const h = o - (o - Math.min(a, r)) / 2 * l;
                                return {
                                    chunk: Math.abs(r - a) / 2 * l / s,
                                    ratio: i.barPercentage,
                                    start: h
                                }
                            }(t, e, n, s) : function (t, e, s, n) {
                                const o = s.barThickness;
                                let a, r;
                                return i(o) ? (a = e.min * s.categoryPercentage, r = s.barPercentage) : (a = o * n, r = 1), {
                                    chunk: a / n,
                                    ratio: r,
                                    start: e.pixels[t] - a / 2
                                }
                            }(t, e, n, s),
                            c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);
                        l = r.start + r.chunk * c + r.chunk / 2, h = Math.min(a, r.chunk * r.ratio)
                    } else l = s.getPixelForValue(this.getParsed(t)[s.axis], t), h = Math.min(a, e.min * e.ratio);
                    return {
                        base: l - h / 2,
                        head: l + h / 2,
                        center: l,
                        size: h
                    }
                }
                draw() {
                    const t = this._cachedMeta,
                        e = t.vScale,
                        i = t.data,
                        s = i.length;
                    let n = 0;
                    for (; n < s; ++n) null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx)
                }
            }
            Tn.id = "bar", Tn.defaults = {
                datasetElementType: !1,
                dataElementType: "bar",
                categoryPercentage: .8,
                barPercentage: .9,
                grouped: !0,
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["x", "y", "base", "width", "height"]
                    }
                }
            }, Tn.overrides = {
                scales: {
                    _index_: {
                        type: "category",
                        offset: !0,
                        grid: {
                            offset: !0
                        }
                    },
                    _value_: {
                        type: "linear",
                        beginAtZero: !0
                    }
                }
            };
            class Ln extends Ls {
                initialize() {
                    this.enableOptionSharing = !0, super.initialize()
                }
                parsePrimitiveData(t, e, i, s) {
                    const n = super.parsePrimitiveData(t, e, i, s);
                    for (let t = 0; t < n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;
                    return n
                }
                parseArrayData(t, e, i, s) {
                    const n = super.parseArrayData(t, e, i, s);
                    for (let t = 0; t < n.length; t++) {
                        const s = e[i + t];
                        n[t]._custom = r(s[2], this.resolveDataElementOptions(t + i).radius)
                    }
                    return n
                }
                parseObjectData(t, e, i, s) {
                    const n = super.parseObjectData(t, e, i, s);
                    for (let t = 0; t < n.length; t++) {
                        const s = e[i + t];
                        n[t]._custom = r(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius)
                    }
                    return n
                }
                getMaxOverflow() {
                    const t = this._cachedMeta.data;
                    let e = 0;
                    for (let i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);
                    return e > 0 && e
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        {
                            xScale: i,
                            yScale: s
                        } = e,
                        n = this.getParsed(t),
                        o = i.getLabelForValue(n.x),
                        a = s.getLabelForValue(n.y),
                        r = n._custom;
                    return {
                        label: e.label,
                        value: "(" + o + ", " + a + (r ? ", " + r : "") + ")"
                    }
                }
                update(t) {
                    const e = this._cachedMeta.data;
                    this.updateElements(e, 0, e.length, t)
                }
                updateElements(t, e, i, s) {
                    const n = "reset" === s,
                        {
                            iScale: o,
                            vScale: a
                        } = this._cachedMeta,
                        {
                            sharedOptions: r,
                            includeOptions: l
                        } = this._getSharedOptions(e, s),
                        h = o.axis,
                        c = a.axis;
                    for (let d = e; d < e + i; d++) {
                        const e = t[d],
                            i = !n && this.getParsed(d),
                            u = {},
                            f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]),
                            g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);
                        u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? "active" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s)
                    }
                }
                resolveDataElementOptions(t, e) {
                    const i = this.getParsed(t);
                    let s = super.resolveDataElementOptions(t, e);
                    s.$shared && (s = Object.assign({}, s, {
                        $shared: !1
                    }));
                    const n = s.radius;
                    return "active" !== e && (s.radius = 0), s.radius += r(i && i._custom, n), s
                }
            }
            Ln.id = "bubble", Ln.defaults = {
                datasetElementType: !1,
                dataElementType: "point",
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["x", "y", "borderWidth", "radius"]
                    }
                }
            }, Ln.overrides = {
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: () => ""
                        }
                    }
                }
            };
            class En extends Ls {
                constructor(t, e) {
                    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
                }
                linkScales() {}
                parse(t, e) {
                    const i = this.getDataset().data,
                        s = this._cachedMeta;
                    if (!1 === this._parsing) s._parsed = i;
                    else {
                        let o, a, r = t => +i[t];
                        if (n(i[t])) {
                            const {
                                key: t = "value"
                            } = this._parsing;
                            r = e => +y(i[e], t)
                        }
                        for (o = t, a = t + e; o < a; ++o) s._parsed[o] = r(o)
                    }
                }
                _getRotation() {
                    return H(this.options.rotation - 90)
                }
                _getCircumference() {
                    return H(this.options.circumference)
                }
                _getRotationExtents() {
                    let t = O,
                        e = -O;
                    for (let i = 0; i < this.chart.data.datasets.length; ++i)
                        if (this.chart.isDatasetVisible(i)) {
                            const s = this.chart.getDatasetMeta(i).controller,
                                n = s._getRotation(),
                                o = s._getCircumference();
                            t = Math.min(t, n), e = Math.max(e, n + o)
                        } return {
                        rotation: t,
                        circumference: e - t
                    }
                }
                update(t) {
                    const e = this.chart,
                        {
                            chartArea: i
                        } = e,
                        s = this._cachedMeta,
                        n = s.data,
                        o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,
                        a = Math.max((Math.min(i.width, i.height) - o) / 2, 0),
                        r = Math.min(l(this.options.cutout, a), 1),
                        c = this._getRingWeight(this.index),
                        {
                            circumference: d,
                            rotation: u
                        } = this._getRotationExtents(),
                        {
                            ratioX: f,
                            ratioY: g,
                            offsetX: p,
                            offsetY: m
                        } = function (t, e, i) {
                            let s = 1,
                                n = 1,
                                o = 0,
                                a = 0;
                            if (e < O) {
                                const r = t,
                                    l = r + e,
                                    h = Math.cos(r),
                                    c = Math.sin(r),
                                    d = Math.cos(l),
                                    u = Math.sin(l),
                                    f = (t, e, s) => G(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i),
                                    g = (t, e, s) => G(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i),
                                    p = f(0, h, d),
                                    m = f(L, c, u),
                                    b = g(D, h, d),
                                    x = g(D + L, c, u);
                                s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2
                            }
                            return {
                                ratioX: s,
                                ratioY: n,
                                offsetX: o,
                                offsetY: a
                            }
                        }(u, d, r),
                        b = (i.width - o) / f,
                        x = (i.height - o) / g,
                        _ = Math.max(Math.min(b, x) / 2, 0),
                        y = h(this.options.radius, _),
                        v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();
                    this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * c, 0), this.updateElements(n, 0, n.length, t)
                }
                _circumference(t, e) {
                    const i = this.options,
                        s = this._cachedMeta,
                        n = this._getCircumference();
                    return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O)
                }
                updateElements(t, e, i, s) {
                    const n = "reset" === s,
                        o = this.chart,
                        a = o.chartArea,
                        r = o.options.animation,
                        l = (a.left + a.right) / 2,
                        h = (a.top + a.bottom) / 2,
                        c = n && r.animateScale,
                        d = c ? 0 : this.innerRadius,
                        u = c ? 0 : this.outerRadius,
                        {
                            sharedOptions: f,
                            includeOptions: g
                        } = this._getSharedOptions(e, s);
                    let p, m = this._getRotation();
                    for (p = 0; p < e; ++p) m += this._circumference(p, n);
                    for (p = e; p < e + i; ++p) {
                        const e = this._circumference(p, n),
                            i = t[p],
                            o = {
                                x: l + this.offsetX,
                                y: h + this.offsetY,
                                startAngle: m,
                                endAngle: m + e,
                                circumference: e,
                                outerRadius: u,
                                innerRadius: d
                            };
                        g && (o.options = f || this.resolveDataElementOptions(p, i.active ? "active" : s)), m += e, this.updateElement(i, p, o, s)
                    }
                }
                calculateTotal() {
                    const t = this._cachedMeta,
                        e = t.data;
                    let i, s = 0;
                    for (i = 0; i < e.length; i++) {
                        const n = t._parsed[i];
                        null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n))
                    }
                    return s
                }
                calculateCircumference(t) {
                    const e = this._cachedMeta.total;
                    return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = this.chart,
                        s = i.data.labels || [],
                        n = li(e._parsed[t], i.options.locale);
                    return {
                        label: s[t] || "",
                        value: n
                    }
                }
                getMaxBorderWidth(t) {
                    let e = 0;
                    const i = this.chart;
                    let s, n, o, a, r;
                    if (!t)
                        for (s = 0, n = i.data.datasets.length; s < n; ++s)
                            if (i.isDatasetVisible(s)) {
                                o = i.getDatasetMeta(s), t = o.data, a = o.controller;
                                break
                            } if (!t) return 0;
                    for (s = 0, n = t.length; s < n; ++s) r = a.resolveDataElementOptions(s), "inner" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
                    return e
                }
                getMaxOffset(t) {
                    let e = 0;
                    for (let i = 0, s = t.length; i < s; ++i) {
                        const t = this.resolveDataElementOptions(i);
                        e = Math.max(e, t.offset || 0, t.hoverOffset || 0)
                    }
                    return e
                }
                _getRingWeightOffset(t) {
                    let e = 0;
                    for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
                    return e
                }
                _getRingWeight(t) {
                    return Math.max(r(this.chart.data.datasets[t].weight, 1), 0)
                }
                _getVisibleDatasetWeightTotal() {
                    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
                }
            }
            En.id = "doughnut", En.defaults = {
                datasetElementType: !1,
                dataElementType: "arc",
                animation: {
                    animateRotate: !0,
                    animateScale: !1
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
                    }
                },
                cutout: "50%",
                rotation: 0,
                circumference: 360,
                radius: "100%",
                spacing: 0,
                indexAxis: "r"
            }, En.descriptors = {
                _scriptable: t => "spacing" !== t,
                _indexable: t => "spacing" !== t
            }, En.overrides = {
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(t) {
                                const e = t.data;
                                if (e.labels.length && e.datasets.length) {
                                    const {
                                        labels: {
                                            pointStyle: i
                                        }
                                    } = t.legend.options;
                                    return e.labels.map(((e, s) => {
                                        const n = t.getDatasetMeta(0).controller.getStyle(s);
                                        return {
                                            text: e,
                                            fillStyle: n.backgroundColor,
                                            strokeStyle: n.borderColor,
                                            lineWidth: n.borderWidth,
                                            pointStyle: i,
                                            hidden: !t.getDataVisibility(s),
                                            index: s
                                        }
                                    }))
                                }
                                return []
                            }
                        },
                        onClick(t, e, i) {
                            i.chart.toggleDataVisibility(e.index), i.chart.update()
                        }
                    },
                    tooltip: {
                        callbacks: {
                            title: () => "",
                            label(t) {
                                let e = t.label;
                                const i = ": " + t.formattedValue;
                                return s(e) ? (e = e.slice(), e[0] += i) : e += i, e
                            }
                        }
                    }
                }
            };
            class Rn extends Ls {
                initialize() {
                    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize()
                }
                update(t) {
                    const e = this._cachedMeta,
                        {
                            dataset: i,
                            data: s = [],
                            _dataset: n
                        } = e,
                        o = this.chart._animationsDisabled;
                    let {
                        start: a,
                        count: r
                    } = gt(e, s, o);
                    this._drawStart = a, this._drawCount = r, pt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;
                    const l = this.resolveDatasetElementOptions(t);
                    this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
                        animated: !o,
                        options: l
                    }, t), this.updateElements(s, a, r, t)
                }
                updateElements(t, e, s, n) {
                    const o = "reset" === n,
                        {
                            iScale: a,
                            vScale: r,
                            _stacked: l,
                            _dataset: h
                        } = this._cachedMeta,
                        {
                            sharedOptions: c,
                            includeOptions: d
                        } = this._getSharedOptions(e, n),
                        u = a.axis,
                        f = r.axis,
                        {
                            spanGaps: g,
                            segment: p
                        } = this.options,
                        m = B(g) ? g : Number.POSITIVE_INFINITY,
                        b = this.chart._animationsDisabled || o || "none" === n;
                    let x = e > 0 && this.getParsed(e - 1);
                    for (let g = e; g < e + s; ++g) {
                        const e = t[g],
                            s = this.getParsed(g),
                            _ = b ? e : {},
                            y = i(s[f]),
                            v = _[u] = a.getPixelForValue(s[u], g),
                            w = _[f] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[f], g);
                        _.skip = isNaN(v) || isNaN(w) || y, _.stop = g > 0 && Math.abs(s[u] - x[u]) > m, p && (_.parsed = s, _.raw = h.data[g]), d && (_.options = c || this.resolveDataElementOptions(g, e.active ? "active" : n)), b || this.updateElement(e, g, _, n), x = s
                    }
                }
                getMaxOverflow() {
                    const t = this._cachedMeta,
                        e = t.dataset,
                        i = e.options && e.options.borderWidth || 0,
                        s = t.data || [];
                    if (!s.length) return i;
                    const n = s[0].size(this.resolveDataElementOptions(0)),
                        o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
                    return Math.max(i, n, o) / 2
                }
                draw() {
                    const t = this._cachedMeta;
                    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw()
                }
            }
            Rn.id = "line", Rn.defaults = {
                datasetElementType: "line",
                dataElementType: "point",
                showLine: !0,
                spanGaps: !1
            }, Rn.overrides = {
                scales: {
                    _index_: {
                        type: "category"
                    },
                    _value_: {
                        type: "linear"
                    }
                }
            };
            class In extends Ls {
                constructor(t, e) {
                    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
                }
                getLabelAndValue(t) {
                    const e = this._cachedMeta,
                        i = this.chart,
                        s = i.data.labels || [],
                        n = li(e._parsed[t].r, i.options.locale);
                    return {
                        label: s[t] || "",
                        value: n
                    }
                }
                parseObjectData(t, e, i, s) {
                    return Ue.bind(this)(t, e, i, s)
                }
                update(t) {
                    const e = this._cachedMeta.data;
                    this._updateRadius(), this.updateElements(e, 0, e.length, t)
                }
                getMinMax() {
                    const t = this._cachedMeta,
                        e = {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY
                        };
                    return t.data.forEach(((t, i) => {
                        const s = this.getParsed(i).r;
                        !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s))
                    })), e
                }
                _updateRadius() {
                    const t = this.chart,
                        e = t.chartArea,
                        i = t.options,
                        s = Math.min(e.right - e.left, e.bottom - e.top),
                        n = Math.max(s / 2, 0),
                        o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
                    this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o
                }
                updateElements(t, e, i, s) {
                    const n = "reset" === s,
                        o = this.chart,
                        a = o.options.animation,
                        r = this._cachedMeta.rScale,
                        l = r.xCenter,
                        h = r.yCenter,
                        c = r.getIndexAngle(0) - .5 * D;
                    let d, u = c;
                    const f = 360 / this.countVisibleElements();
                    for (d = 0; d < e; ++d) u += this._computeAngle(d, s, f);
                    for (d = e; d < e + i; d++) {
                        const e = t[d];
                        let i = u,
                            g = u + this._computeAngle(d, s, f),
                            p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;
                        u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));
                        const m = {
                            x: l,
                            y: h,
                            innerRadius: 0,
                            outerRadius: p,
                            startAngle: i,
                            endAngle: g,
                            options: this.resolveDataElementOptions(d, e.active ? "active" : s)
                        };
                        this.updateElement(e, d, m, s)
                    }
                }
                countVisibleElements() {
                    const t = this._cachedMeta;
                    let e = 0;
                    return t.data.forEach(((t, i) => {
                        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++
                    })), e
                }
                _computeAngle(t, e, i) {
                    return this.chart.getDataVisibility(t) ? H(this.resolveDataElementOptions(t, e).angle || i) : 0
                }
            }
            In.id = "polarArea", In.defaults = {
                dataElementType: "arc",
                animation: {
                    animateRotate: !0,
                    animateScale: !0
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
                    }
                },
                indexAxis: "r",
                startAngle: 0
            }, In.overrides = {
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(t) {
                                const e = t.data;
                                if (e.labels.length && e.datasets.length) {
                                    const {
                                        labels: {
                                            pointStyle: i
                                        }
                                    } = t.legend.options;
                                    return e.labels.map(((e, s) => {
                                        const n = t.getDatasetMeta(0).controller.getStyle(s);
                                        return {
                                            text: e,
                                            fillStyle: n.backgroundColor,
                                            strokeStyle: n.borderColor,
                                            lineWidth: n.borderWidth,
                                            pointStyle: i,
                                            hidden: !t.getDataVisibility(s),
                                            index: s
                                        }
                                    }))
                                }
                                return []
                            }
                        },
                        onClick(t, e, i) {
                            i.chart.toggleDataVisibility(e.index), i.chart.update()
                        }
                    },
                    tooltip: {
                        callbacks: {
                            title: () => "",
                            label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
                        }
                    }
                },
                scales: {
                    r: {
                        type: "radialLinear",
                        angleLines: {
                            display: !1
                        },
                        beginAtZero: !0,
                        grid: {
                            circular: !0
                        },
                        pointLabels: {
                            display: !1
                        },
                        startAngle: 0
                    }
                }
            };
            class zn extends En {}
            zn.id = "pie", zn.defaults = {
                cutout: 0,
                rotation: 0,
                circumference: 360,
                radius: "100%"
            };
            class Fn extends Ls {
                getLabelAndValue(t) {
                    const e = this._cachedMeta.vScale,
                        i = this.getParsed(t);
                    return {
                        label: e.getLabels()[t],
                        value: "" + e.getLabelForValue(i[e.axis])
                    }
                }
                parseObjectData(t, e, i, s) {
                    return Ue.bind(this)(t, e, i, s)
                }
                update(t) {
                    const e = this._cachedMeta,
                        i = e.dataset,
                        s = e.data || [],
                        n = e.iScale.getLabels();
                    if (i.points = s, "resize" !== t) {
                        const e = this.resolveDatasetElementOptions(t);
                        this.options.showLine || (e.borderWidth = 0);
                        const o = {
                            _loop: !0,
                            _fullLoop: n.length === s.length,
                            options: e
                        };
                        this.updateElement(i, void 0, o, t)
                    }
                    this.updateElements(s, 0, s.length, t)
                }
                updateElements(t, e, i, s) {
                    const n = this._cachedMeta.rScale,
                        o = "reset" === s;
                    for (let a = e; a < e + i; a++) {
                        const e = t[a],
                            i = this.resolveDataElementOptions(a, e.active ? "active" : s),
                            r = n.getPointPositionForValue(a, this.getParsed(a).r),
                            l = o ? n.xCenter : r.x,
                            h = o ? n.yCenter : r.y,
                            c = {
                                x: l,
                                y: h,
                                angle: r.angle,
                                skip: isNaN(l) || isNaN(h),
                                options: i
                            };
                        this.updateElement(e, a, c, s)
                    }
                }
            }
            Fn.id = "radar", Fn.defaults = {
                datasetElementType: "line",
                dataElementType: "point",
                indexAxis: "r",
                showLine: !0,
                elements: {
                    line: {
                        fill: "start"
                    }
                }
            }, Fn.overrides = {
                aspectRatio: 1,
                scales: {
                    r: {
                        type: "radialLinear"
                    }
                }
            };
            class Vn extends Ls {
                update(t) {
                    const e = this._cachedMeta,
                        {
                            data: i = []
                        } = e,
                        s = this.chart._animationsDisabled;
                    let {
                        start: n,
                        count: o
                    } = gt(e, i, s);
                    if (this._drawStart = n, this._drawCount = o, pt(e) && (n = 0, o = i.length), this.options.showLine) {
                        const {
                            dataset: n,
                            _dataset: o
                        } = e;
                        n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;
                        const a = this.resolveDatasetElementOptions(t);
                        a.segment = this.options.segment, this.updateElement(n, void 0, {
                            animated: !s,
                            options: a
                        }, t)
                    }
                    this.updateElements(i, n, o, t)
                }
                addElements() {
                    const {
                        showLine: t
                    } = this.options;
                    !this.datasetElementType && t && (this.datasetElementType = Us.getElement("line")), super.addElements()
                }
                updateElements(t, e, s, n) {
                    const o = "reset" === n,
                        {
                            iScale: a,
                            vScale: r,
                            _stacked: l,
                            _dataset: h
                        } = this._cachedMeta,
                        c = this.resolveDataElementOptions(e, n),
                        d = this.getSharedOptions(c),
                        u = this.includeOptions(n, d),
                        f = a.axis,
                        g = r.axis,
                        {
                            spanGaps: p,
                            segment: m
                        } = this.options,
                        b = B(p) ? p : Number.POSITIVE_INFINITY,
                        x = this.chart._animationsDisabled || o || "none" === n;
                    let _ = e > 0 && this.getParsed(e - 1);
                    for (let c = e; c < e + s; ++c) {
                        const e = t[c],
                            s = this.getParsed(c),
                            p = x ? e : {},
                            y = i(s[g]),
                            v = p[f] = a.getPixelForValue(s[f], c),
                            w = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[g], c);
                        p.skip = isNaN(v) || isNaN(w) || y, p.stop = c > 0 && Math.abs(s[f] - _[f]) > b, m && (p.parsed = s, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? "active" : n)), x || this.updateElement(e, c, p, n), _ = s
                    }
                    this.updateSharedOptions(d, n, c)
                }
                getMaxOverflow() {
                    const t = this._cachedMeta,
                        e = t.data || [];
                    if (!this.options.showLine) {
                        let t = 0;
                        for (let i = e.length - 1; i >= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);
                        return t > 0 && t
                    }
                    const i = t.dataset,
                        s = i.options && i.options.borderWidth || 0;
                    if (!e.length) return s;
                    const n = e[0].size(this.resolveDataElementOptions(0)),
                        o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
                    return Math.max(s, n, o) / 2
                }
            }
            Vn.id = "scatter", Vn.defaults = {
                datasetElementType: !1,
                dataElementType: "point",
                showLine: !1,
                fill: !1
            }, Vn.overrides = {
                interaction: {
                    mode: "point"
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            title: () => "",
                            label: t => "(" + t.label + ", " + t.formattedValue + ")"
                        }
                    }
                },
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                }
            };
            var Bn = Object.freeze({
                __proto__: null,
                BarController: Tn,
                BubbleController: Ln,
                DoughnutController: En,
                LineController: Rn,
                PolarAreaController: In,
                PieController: zn,
                RadarController: Fn,
                ScatterController: Vn
            });

            function Nn(t, e, i) {
                const {
                    startAngle: s,
                    pixelMargin: n,
                    x: o,
                    y: a,
                    outerRadius: r,
                    innerRadius: l
                } = e;
                let h = n / r;
                t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + L, s - L), t.closePath(), t.clip()
            }

            function Wn(t, e, i, s) {
                const n = ui(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
                const o = (i - e) / 2,
                    a = Math.min(o, s * e / 2),
                    r = t => {
                        const e = (i - Math.min(o, t)) * s / 2;
                        return Z(t, 0, Math.min(o, e))
                    };
                return {
                    outerStart: r(n.outerStart),
                    outerEnd: r(n.outerEnd),
                    innerStart: Z(n.innerStart, 0, a),
                    innerEnd: Z(n.innerEnd, 0, a)
                }
            }

            function jn(t, e, i, s) {
                return {
                    x: i + t * Math.cos(e),
                    y: s + t * Math.sin(e)
                }
            }

            function Hn(t, e, i, s, n, o) {
                const {
                    x: a,
                    y: r,
                    startAngle: l,
                    pixelMargin: h,
                    innerRadius: c
                } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;
                let f = 0;
                const g = n - l;
                if (s) {
                    const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;
                    f = (g - (0 !== t ? g * t / (t + s) : g)) / 2
                }
                const p = (g - Math.max(.001, g * d - i / D) / d) / 2,
                    m = l + p + f,
                    b = n - p - f,
                    {
                        outerStart: x,
                        outerEnd: _,
                        innerStart: y,
                        innerEnd: v
                    } = Wn(e, u, d, b - m),
                    w = d - x,
                    M = d - _,
                    k = m + x / w,
                    S = b - _ / M,
                    P = u + y,
                    O = u + v,
                    C = m + y / P,
                    A = b - v / O;
                if (t.beginPath(), o) {
                    if (t.arc(a, r, d, k, S), _ > 0) {
                        const e = jn(M, S, a, r);
                        t.arc(e.x, e.y, _, S, b + L)
                    }
                    const e = jn(O, b, a, r);
                    if (t.lineTo(e.x, e.y), v > 0) {
                        const e = jn(O, A, a, r);
                        t.arc(e.x, e.y, v, b + L, A + Math.PI)
                    }
                    if (t.arc(a, r, u, b - v / u, m + y / u, !0), y > 0) {
                        const e = jn(P, C, a, r);
                        t.arc(e.x, e.y, y, C + Math.PI, m - L)
                    }
                    const i = jn(w, m, a, r);
                    if (t.lineTo(i.x, i.y), x > 0) {
                        const e = jn(w, k, a, r);
                        t.arc(e.x, e.y, x, m - L, k)
                    }
                } else {
                    t.moveTo(a, r);
                    const e = Math.cos(k) * d + a,
                        i = Math.sin(k) * d + r;
                    t.lineTo(e, i);
                    const s = Math.cos(S) * d + a,
                        n = Math.sin(S) * d + r;
                    t.lineTo(s, n)
                }
                t.closePath()
            }

            function $n(t, e, i, s, n, o) {
                const {
                    options: a
                } = e, {
                    borderWidth: r,
                    borderJoinStyle: l
                } = a, h = "inner" === a.borderAlign;
                r && (h ? (t.lineWidth = 2 * r, t.lineJoin = l || "round") : (t.lineWidth = r, t.lineJoin = l || "bevel"), e.fullCircles && function (t, e, i) {
                    const {
                        x: s,
                        y: n,
                        startAngle: o,
                        pixelMargin: a,
                        fullCircles: r
                    } = e, l = Math.max(e.outerRadius - a, 0), h = e.innerRadius + a;
                    let c;
                    for (i && Nn(t, e, o + O), t.beginPath(), t.arc(s, n, h, o + O, o, !0), c = 0; c < r; ++c) t.stroke();
                    for (t.beginPath(), t.arc(s, n, l, o, o + O), c = 0; c < r; ++c) t.stroke()
                }(t, e, h), h && Nn(t, e, n), Hn(t, e, i, s, n, o), t.stroke())
            }
            class Yn extends Es {
                constructor(t) {
                    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
                }
                inRange(t, e, i) {
                    const s = this.getProps(["x", "y"], i),
                        {
                            angle: n,
                            distance: o
                        } = U(s, {
                            x: t,
                            y: e
                        }),
                        {
                            startAngle: a,
                            endAngle: l,
                            innerRadius: h,
                            outerRadius: c,
                            circumference: d
                        } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i),
                        u = this.options.spacing / 2,
                        f = r(d, l - a) >= O || G(n, a, l),
                        g = Q(o, h + u, c + u);
                    return f && g
                }
                getCenterPoint(t) {
                    const {
                        x: e,
                        y: i,
                        startAngle: s,
                        endAngle: n,
                        innerRadius: o,
                        outerRadius: a
                    } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t), {
                        offset: r,
                        spacing: l
                    } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;
                    return {
                        x: e + Math.cos(h) * c,
                        y: i + Math.sin(h) * c
                    }
                }
                tooltipPosition(t) {
                    return this.getCenterPoint(t)
                }
                draw(t) {
                    const {
                        options: e,
                        circumference: i
                    } = this, s = (e.offset || 0) / 2, n = (e.spacing || 0) / 2, o = e.circular;
                    if (this.pixelMargin = "inner" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;
                    t.save();
                    let a = 0;
                    if (s) {
                        a = s / 2;
                        const e = (this.startAngle + this.endAngle) / 2;
                        t.translate(Math.cos(e) * a, Math.sin(e) * a), this.circumference >= D && (a = s)
                    }
                    t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;
                    const r = function (t, e, i, s, n) {
                        const {
                            fullCircles: o,
                            startAngle: a,
                            circumference: r
                        } = e;
                        let l = e.endAngle;
                        if (o) {
                            Hn(t, e, i, s, a + O, n);
                            for (let e = 0; e < o; ++e) t.fill();
                            isNaN(r) || (l = a + r % O, r % O == 0 && (l += O))
                        }
                        return Hn(t, e, i, s, l, n), t.fill(), l
                    }(t, this, a, n, o);
                    $n(t, this, a, n, r, o), t.restore()
                }
            }

            function Un(t, e, i = e) {
                t.lineCap = r(i.borderCapStyle, e.borderCapStyle), t.setLineDash(r(i.borderDash, e.borderDash)), t.lineDashOffset = r(i.borderDashOffset, e.borderDashOffset), t.lineJoin = r(i.borderJoinStyle, e.borderJoinStyle